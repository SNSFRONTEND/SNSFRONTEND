<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SNS前端团队</title>
  <icon>https://www.gravatar.com/avatar/6f11d878552e5c9aa6131de5e6f92f46</icon>
  <subtitle>点点滴滴-破茧成蝶</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://snsfrontend.crysnower.cn/"/>
  <updated>2018-05-21T06:44:49.678Z</updated>
  <id>http://snsfrontend.crysnower.cn/</id>
  
  <author>
    <name>SNS前端团队</name>
    <email>stephenzhumail@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UIStackView基础用法介绍</title>
    <link href="http://snsfrontend.crysnower.cn/UIStackView%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D.html"/>
    <id>http://snsfrontend.crysnower.cn/UIStackView基础用法介绍.html</id>
    <published>2018-05-21T01:27:19.000Z</published>
    <updated>2018-05-21T06:44:49.678Z</updated>
    
    <content type="html"><![CDATA[<p>介绍</p><p>UIStackView 是 iOS9新增的一个布局技术。熟练掌握相当节省布局时间。<br>UIStackView 是 UIView 的子类，是用来约束子控件的一个控件。但他的作用仅限于此，他不能用来呈现自身的内容，类似于 backgroundColor。当然了，这个控件相当易学，属性只有4个。</p><p><img src="https://o909w11l5.qnssl.com/2016-07-20-屏幕快照%202016-07-20%2016.52.41.png" alt="alt text"></p><p>Axls: 子控件的布局方向，水平或者垂直<br>Alignment: 类似于 UILabel 的 Alignment 属性<br>Distributlon: 子控件的大小<br>Spacing: 子控件间的间距</p><p>可以看到在属性左边有个加号，点开来是这样的：</p><p><img src="https://o909w11l5.qnssl.com/2016-07-20-屏幕快照%202016-07-20%2016.57.50.png" alt="alt text"></p><p>这其实是 UIStackView 也集成了 Size Class，Size Class 是用来布局不同尺寸屏幕的。在这里可以通过选择不同的尺寸来更新子控件约束。</p><p>使用</p><p>接下来我们在 IB 中使用 UIStackView 来完成以下布局：<br><img src="https://o909w11l5.qnssl.com/2016-07-20-屏幕快照%202016-07-20%2017.23.53.png" alt="alt text"><br>首先上面的 ImageView 是直接做约束完成的。<br>然后我们可以选择左下角的三个 Label,然后点击右下角第一个图标合成 UIStackView:</p><p>因为三个 Label 间是有间距的，所以接下来我们修改 Spacing 属性：<br><img src="https://o909w11l5.qnssl.com/2016-07-20-屏幕快照%202016-07-20%2017.29.29.png" alt="alt text"><br>这样就很方便的做好了 UIStackView 内部子视图的布局，然后只需要给 UIStackView 设置离左边和下边的约束即可，因为这个 UIStackView 内部的子视图都是 UILabel, UILabel 都是有他自身的固有大小的，所以不需要设置4个布局。<br><img src="https://o909w11l5.qnssl.com/2016-07-20-屏幕快照%202016-07-20%2017.31.28.png" alt="alt text"><br>这样我们就完成了左边三个 Lable 的布局。接下来我们来布局右边的2个控件。</p><p>还是和刚才一样，选择 Image 和 label，并且组成一个 UIStackView 并设置好 UIStackView 的布局约束：<br><img src="https://o909w11l5.qnssl.com/2016-07-20-屏幕快照%202016-07-20%2017.33.03.png" alt="alt text"><br>接下来布局内部子控件约束：<br><img src="https://o909w11l5.qnssl.com/2016-07-20-屏幕快照%202016-07-20%2017.33.34.png" alt="alt text"><br>做好这两步你会发现 IB 还是报错，这是因为 UIStackView 并不知道他内部的 image 的宽高，这时候我们可以让 image 有他的固有大小：<br><img src="https://o909w11l5.qnssl.com/2016-07-20-屏幕快照%202016-07-20%2017.35.10.png" alt="alt text"><br>将 intrinsic Size 的属性改为 Placeholder，这时候就解决了报错，至此，整个 View 的约束已经做完，是不是发现比之前全部用 Auto Layout 快多了。</p><p>当然了 UIStackView 也是可以用代码创建的。</p><pre><code>class UIStackView : UIView {init(arrangedSubviews views: [UIView]) var arrangedSubviews: [UIView] { get }func addArrangedSubview(view: UIView) func removeArrangedSubview(view: UIView) func insertArrangedSubview(view: UIView, atIndex stackIndex: Int) ... }</code></pre><p>第一个方法是用来创建一个 UIStackView 的，传入 views 里的数组的顺序代表了 UIStackView 里子视图的顺序。<br>第二个方法是用来获得 UIStackView 里有哪些子视图的。</p><p>后面3个方法和 UIView 里的方法是类似的。<br>看到 addArrangedSubview 和 removeArrangedSubview 你是不是想到了addSubView 和removfromSuperView。</p><p>下面有张表，可以区别这四个方法：<br><img src="https://o909w11l5.qnssl.com/2016-07-20-屏幕快照%202016-07-20%2017.44.56.png" alt="alt text"><br>从表中可以看出，添加 UIStackView 的子视图应该用 addArrangedSubview，移除 UIStackView 某个子视图应该用 removeArrangedSubview。</p><p>UIStackView 用来约束子视图的属性有以下几个</p><pre><code>var axis: UILayoutConstraintAxis var distribution: UIStackViewDistribution var alignment: UIStackViewAlignment var spacing: CGFloat var baselineRelativeArrangement: Bool var layoutMarginsRelativeArrangement: Bool</code></pre><p>这些就是使用代码来创建 UIStackView 了。</p><p>UIStackView 还是蛮简单的，但是功能却十分强大。这篇文章应该能让大家了解 UIStackView 的基本使用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;介绍&lt;/p&gt;
&lt;p&gt;UIStackView 是 iOS9新增的一个布局技术。熟练掌握相当节省布局时间。&lt;br&gt;UIStackView 是 UIView 的子类，是用来约束子控件的一个控件。但他的作用仅限于此，他不能用来呈现自身的内容，类似于 backgroundColor。
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>螺与螺</title>
    <link href="http://snsfrontend.crysnower.cn/%E8%9E%BA%E4%B8%8E%E9%B1%BC.html"/>
    <id>http://snsfrontend.crysnower.cn/螺与鱼.html</id>
    <published>2018-05-20T07:53:16.867Z</published>
    <updated>2018-05-21T06:32:58.008Z</updated>
    
    <content type="html"><![CDATA[<h3 id="螺与鱼"><a href="#螺与鱼" class="headerlink" title="螺与鱼"></a>螺与鱼</h3><p>我喜欢养鱼，尤其是草缸里的热带鱼。</p><p><img src="/images/redaiyu.jpg" alt="热带鱼"></p><p>大公司内部就是一个小社会，有不同的分工，形形色色的人，咱今天不讲这么大，说说小草缸。我给它维持着生长所需要的Co2，光照，水温，过滤，硝化细菌种群，精确配比。越来越发觉，这分明就是一个小团队，各职能部门相互协同、配合，达到水草茂盛、鱼儿欢乐的目标。<br>最近发生的一些事情对我触动还是挺大的，翻缸初期，褐藻和蓝藻大爆发，于是故事开始了。</p><ul><li>目标<br>为了除藻在某宝买了一堆活物，分别是杀手螺和小精灵。杀手螺是食肉，用来清理鱼虾尸体的，小精灵可以食藻。于是除藻就成了目标，买的活物把藻都吃掉就是方案。<br>ps：除藻你买食肉螺干什么？淘宝套餐，搭配着卖的，更便宜！<br>由于快递运输损耗，第二天就有一条小精灵肚皮朝上沉底了，上班匆忙也就没顾太多，心想刚好借此机会检验一下杀手螺的能力。</li><li>意外收获<br>白天的时候买的第二波活物又到了，这次是一种好食藻类的黑金刚螺。晚上回到家的时候，挂掉的那一条小精灵已经被杀手螺吃得只剩下骨架了，我看在了眼里，很是欣慰，感觉自己更加接近目标了。黑金刚们也被我一个一个扔进了草缸。</li><li>期望值<br>第二天早上醒来的时候，大大的惊喜。原本厚厚一层的褐藻被黑金刚吃的斑斑勃勃，到了晚上已经窗明几净了，到这时候应该算是达成了目标，因为除藻效果已经大大超出了我的期望。可是故事还远远没有结束，到了晚上，就是晚上，意外的发现有一只黑金刚的壳空了，或许我应该骗自己说黑金刚把房子卖了旅游去了。</li><li>失控<br>我搬了一个凳子坐在了草缸前，以上帝视角观察它们。几只杀手螺对一只黑金刚围追堵截，相比黑金刚的速度杀手螺简直在飞。不一会儿黑金刚身上爬满了三只杀手螺，等等，空壳就是这么被吃掉的？我用水草镊把黑金刚身上的三只杀手螺夹到了远处，这才放心了。<br>第二天晚上，开水草灯，发现又多了两个空壳。黑金刚的肉被拽了出来，几乎所有的杀手螺正在享用。心想，吃螺丝不得用牙签嘛？这个操作很少见啊。这才意识到，杀手螺竟然可以不用牙签就能吃到螺丝肉，情况已经完全失控了，只能把杀手螺请出草缸。</li><li>稳定<br>接下来可以放心开灯了，不用担心爆藻了。</li><li>事后诸葛亮<br>回过头来看看，起初目标很简单，就是除藻。杀手螺把小精灵的尸体吃掉确实让我很欣慰，当时还后悔买少了，可是这和我的目标并没有关系，却给我造成了一种接近目标的喜悦感，而这种喜悦感、认同感却并不能帮助我完成除藻的目标。但也得承认杀手螺处理尸体的能力确实不凡，但是却被我用错了地方，这种资源的引入不但没能帮助我更快更好的完成目标，反而拖慢了整体进度。<br>当然，无论是团队管理还是项目管理，比这要复杂得多，首先你不具备上帝视角，其次你自己也很有可能偶尔扮演杀手螺的角色，这就需要时刻自省，若自省不及还得依靠团队机制，下一篇《罪与罚》。<br>理当直言不讳相互谏言，与君同行，携手进步。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;螺与鱼&quot;&gt;&lt;a href=&quot;#螺与鱼&quot; class=&quot;headerlink&quot; title=&quot;螺与鱼&quot;&gt;&lt;/a&gt;螺与鱼&lt;/h3&gt;&lt;p&gt;我喜欢养鱼，尤其是草缸里的热带鱼。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/redaiyu.jpg&quot; alt=&quot;热带鱼&quot;&gt;
      
    
    </summary>
    
      <category term="项目管理" scheme="http://snsfrontend.crysnower.cn/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="项目管理" scheme="http://snsfrontend.crysnower.cn/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>URL 编码 iOS</title>
    <link href="http://snsfrontend.crysnower.cn/URL-%E7%BC%96%E7%A0%81-iOS.html"/>
    <id>http://snsfrontend.crysnower.cn/URL-编码-iOS.html</id>
    <published>2018-05-20T07:05:46.000Z</published>
    <updated>2018-05-21T06:27:52.424Z</updated>
    
    <content type="html"><![CDATA[<h3 id="URL-编码-iOS"><a href="#URL-编码-iOS" class="headerlink" title="URL 编码 iOS"></a>URL 编码 iOS</h3><p>废弃的方法1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *aa = [@&quot;http://URL...&quot; stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</span><br></pre></td></tr></table></figure><p>废弃的方法2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)encodeParameter:(NSString *)originalPara &#123;</span><br><span class="line">    CFStringRef encodeParaCf = CFURLCreateStringByAddingPercentEscapes(NULL, (__bridge CFStringRef)originalPara, NULL, CFSTR(&quot;!*&apos;();:@&amp;=+$,/?%#[]&quot;), kCFStringEncodingUTF8);</span><br><span class="line">    NSString *encodePara = (__bridge NSString *)(encodeParaCf);</span><br><span class="line">    CFRelease(encodeParaCf);</span><br><span class="line">    return encodePara;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)testURL &#123;</span><br><span class="line">    NSString *charactersToEscape = @&quot;&amp;?=&quot;;</span><br><span class="line">    NSCharacterSet *allowedCharacters = [[NSCharacterSet characterSetWithCharactersInString:charactersToEscape] invertedSet];</span><br><span class="line">    /**</span><br><span class="line">     使用预置的，如果不能满足要求，则使用自定义characterSetWithCharactersInString</span><br><span class="line">    NSCharacterSet *allowedCharacters = [NSCharacterSet URLHostAllowedCharacterSet];</span><br><span class="line">     URLHostAllowedCharacterSet      &quot;#%/&lt;&gt;?@\^`&#123;|&#125;</span><br><span class="line">     URLFragmentAllowedCharacterSet  &quot;#%&lt;&gt;[\]^`&#123;|&#125;</span><br><span class="line">     URLPasswordAllowedCharacterSet  &quot;#%/:&lt;&gt;?@[\]^`&#123;|&#125;</span><br><span class="line">     URLPathAllowedCharacterSet      &quot;#%;&lt;&gt;?[\]^`&#123;|&#125;</span><br><span class="line">     URLQueryAllowedCharacterSet     &quot;#%&lt;&gt;[\]^`&#123;|&#125;</span><br><span class="line">     URLUserAllowedCharacterSet      &quot;#%/:&lt;&gt;?@[\]^`</span><br><span class="line">     **/</span><br><span class="line">    NSString *encodedUrl = [@&quot;htt://baidu.com/a.do?p1=中文&amp;p2=http://baidu.com/a?p11=x&amp;p12=xx&quot; stringByAddingPercentEncodingWithAllowedCharacters:allowedCharacters];</span><br><span class="line">    NSLog(@&quot;%@&quot;, encodedUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps:</p><p>在有些时候，如果业务需要url包含签名之类的参数，大多数情况下请勿对sign等签名字段转码，除非签名验证方也对sign进行解码操作，具体开发过程中还是需要根据交互协议来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;URL-编码-iOS&quot;&gt;&lt;a href=&quot;#URL-编码-iOS&quot; class=&quot;headerlink&quot; title=&quot;URL 编码 iOS&quot;&gt;&lt;/a&gt;URL 编码 iOS&lt;/h3&gt;&lt;p&gt;废弃的方法1：&lt;/p&gt;
&lt;figure class=&quot;highlight p
      
    
    </summary>
    
      <category term="iOS" scheme="http://snsfrontend.crysnower.cn/categories/iOS/"/>
    
    
      <category term="基础" scheme="http://snsfrontend.crysnower.cn/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>ios修改本地useragent(WKWebView)</title>
    <link href="http://snsfrontend.crysnower.cn/ios%E4%BF%AE%E6%94%B9%E6%9C%AC%E5%9C%B0useragent-WKWebView.html"/>
    <id>http://snsfrontend.crysnower.cn/ios修改本地useragent-WKWebView.html</id>
    <published>2018-05-20T03:50:39.000Z</published>
    <updated>2018-05-20T04:04:20.976Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ios修改本地useragent-WKWebView"><a href="#ios修改本地useragent-WKWebView" class="headerlink" title="ios修改本地useragent(WKWebView)"></a>ios修改本地useragent(WKWebView)</h3><p>1、获取原先的userAgent；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* @abstract Evaluates the given JavaScript string.</span><br><span class="line">@param javaScriptString The JavaScript string to evaluate.</span><br><span class="line">@param completionHandler A block to invoke when script evaluation completes or fails.</span><br><span class="line">@discussion The completionHandler is passed the result of the script evaluation or an error.</span><br><span class="line">*/</span><br><span class="line">- (void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^ _Nullable)(_Nullable id, NSError * _Nullable error))completionHandler;</span><br></pre></td></tr></table></figure><p>这个方法也可以用来解决Native调用JS的问题。</p><p>原生js中获取userAgent的方法就是”navigator.userAgent”。</p><p>2、修改userAgent；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/*! @abstract The custom user agent string or nil if no custom user agent string has been set.</span><br><span class="line">*/</span><br><span class="line">@property (nullable, nonatomic, copy) NSString *customUserAgent API_AVAILABLE(macosx(10.11), ios(9.0));</span><br></pre></td></tr></table></figure><p>WKWebView 类有个customUserAgent属性，赋值即可。</p><p>3、UIWebView里面userAgent的修改方法；</p><p>由于UIWebView有内存泄露问题，不可控，建议大家也使用WKWebView，替换成本还是很小的。</p><p>4、坑；</p><p>大多数人，包括网上很多帖子都写了关于wkweb修改useragent的方法，例如</p><p><a href="https://www.jianshu.com/p/fd6fe72a3b0e" target="_blank" rel="noopener">https://www.jianshu.com/p/fd6fe72a3b0e</a></p><p><a href="https://www.jianshu.com/p/5f02451b8e87" target="_blank" rel="noopener">https://www.jianshu.com/p/5f02451b8e87</a></p><p>这两篇文章是百度搜索的前几个，都提到了修改不生效，“？？需要alloc两遍？？”，还有人提到“？？第一次进入不生效，第二次就ok了？？”。</p><p>仔细看下来不难发现，WKWebView获取userAgent是个异步block过程，那修改userAgent也是在异步里面完成的，既然修改过程是异步，name使用不得等block回调完成再使用么。</p><p>全量代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  DocumentViewController.m</span><br><span class="line">//  Project_20171206</span><br><span class="line">//</span><br><span class="line">//  Created by StephenZhu on 2018/5/14.</span><br><span class="line">//  Copyright © 2018年 StephenZhu. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;DocumentViewController.h&quot;</span><br><span class="line">#import &lt;WebKit/WebKit.h&gt;</span><br><span class="line">@interface DocumentViewController ()</span><br><span class="line">@property (nonatomic,strong) WKWebView *myWebView;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation DocumentViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">[self.view addSubview:self.myWebView];</span><br><span class="line">[self layoutMain];</span><br><span class="line">[self setUserAgent];</span><br><span class="line">&#125;</span><br><span class="line">- (void)layoutMain</span><br><span class="line">&#123;</span><br><span class="line">[self.myWebView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.edges.mas_equalTo(0);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line">- (void)loadUrl</span><br><span class="line">&#123;</span><br><span class="line">NSString* urlStr = [NSString stringWithFormat:@&quot;http://WWW.BAIDU.COM&quot;];</span><br><span class="line">NSURL *url = [NSURL URLWithString:urlStr];</span><br><span class="line">[self.myWebView evaluateJavaScript:@&quot;navigator.userAgent&quot; completionHandler:^(id result, NSError *error) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;,result);</span><br><span class="line">[self.myWebView loadRequest:[NSURLRequest requestWithURL:url]];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">- (void)setUserAgent</span><br><span class="line">&#123;</span><br><span class="line">[self.myWebView evaluateJavaScript:@&quot;navigator.userAgent&quot; completionHandler:^(id result, NSError *error) &#123;</span><br><span class="line">NSString *oldUserAgent = result;</span><br><span class="line">NSString *newUserAgent = [NSString stringWithFormat:@&quot;%@ %@&quot;,oldUserAgent,@&quot;TheNewWordForUserAgent/v1.6&quot;];</span><br><span class="line">self.myWebView.customUserAgent = newUserAgent;</span><br><span class="line">[self loadUrl];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark - lazyload</span><br><span class="line">- (WKWebView *)myWebView</span><br><span class="line">&#123;</span><br><span class="line">if (_myWebView == nil) &#123;</span><br><span class="line">_myWebView = [[WKWebView alloc]initWithFrame:CGRectZero];</span><br><span class="line">&#125;</span><br><span class="line">return _myWebView;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ios修改本地useragent-WKWebView&quot;&gt;&lt;a href=&quot;#ios修改本地useragent-WKWebView&quot; class=&quot;headerlink&quot; title=&quot;ios修改本地useragent(WKWebView)&quot;&gt;&lt;/a&gt;ios修改
      
    
    </summary>
    
      <category term="iOS" scheme="http://snsfrontend.crysnower.cn/categories/iOS/"/>
    
    
      <category term="WKWebView" scheme="http://snsfrontend.crysnower.cn/tags/WKWebView/"/>
    
  </entry>
  
  <entry>
    <title>如何提高字符转float数据时的数据精度</title>
    <link href="http://snsfrontend.crysnower.cn/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%AD%97%E7%AC%A6%E8%BD%ACfloat%E6%95%B0%E6%8D%AE%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B2%BE%E5%BA%A6.html"/>
    <id>http://snsfrontend.crysnower.cn/如何提高字符转float数据时的数据精度.html</id>
    <published>2018-05-12T09:17:00.000Z</published>
    <updated>2018-05-21T06:31:25.378Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中经常遇到float类型数据转化为NSString再进行显示，但是经常遇到精度出错的问题，如下代码：</p><pre><code>float testF = 123.45;NSString *testStr = [NSString stringWithFormat:@&quot;%.2f&quot;,testF];NSLog(@&quot;testF  %f&quot;,testF);NSLog(@&quot;testStr  %@&quot;,testStr);</code></pre><p>按照一般的逻辑，打印出来的日志应该都是123.45才对，不过用测试工程一看就知道打印出来的是：</p><p>2018-05-12 17:23:34.991681+0800 aabbccdd[9469:258142] testF  123.449997<br>2018-05-12 17:23:34.992835+0800 aabbccdd[9469:258142] testStr  123.45</p><p>还有就是从服务端拿到的NSString转换为Float后数据值不准确。<br>苹果有专门的API：NSDecimalNumber。顾名思义这是一个十进制数字类，继承自NSNumber，苹果针对浮点类型计算精度问题提供出来的计算类，基于十进制的科学计数法来计算，同时可以指定舍入模式，一般用于货币计算。</p><p>NSDecimalNumber是NSNumber的不可变子类。苹果针对浮点型计算时存在精度计算误差的问题而提供的一个计算类,它是基于10进制的定点计算保证了精度不会缺失。同时也可以定制精度的取正类型：向上取正、向下去正、四舍五入等。相对与浮点类型的计算，NSDecimalNumber提供了更加精准的计算。</p><p><img src="http://obfk4z1f6.bkt.clouddn.com/fixed-point-representation.png" alt="Alt text"></p><p>一个定点数包含了：用一个尾数（Mantissa）、一个基数（Base）、一个指数（Exponent）以及一个表示正负的符号(sign).<br>比如 15.99 用十进制科学计数法可以表达为 +1599 × 10⁻² ，其中 1.2345 为尾数，10 为基数，2 为指数。sign为 ‘+’。</p><p>代码表示：</p><p>NSDecimalNumber *price;<br>price = [NSDecimalNumber decimalNumberWithMantissa:1599<br>                                          exponent:-2<br>                                          isNegative:NO];</p><p>price = [NSDecimalNumber decimalNumberWithString:@”15.99”];</p><p>// 或者直接由字符串生成NSDecimalNumber<br>price = [NSDecimalNumber decimalNumberWithString:@”15.99”];</p><p>算式：<br>基本的加减乘除用法如下:</p><p>NSDecimalNumber <em>price1 = [NSDecimalNumber decimalNumberWithString:@”15.99”];<br>NSDecimalNumber </em>price2 = [NSDecimalNumber decimalNumberWithString:@”29.99”];<br>NSDecimalNumber <em>coupon = [NSDecimalNumber decimalNumberWithString:@”5.00”];<br>NSDecimalNumber </em>discount = [NSDecimalNumber decimalNumberWithString:@”.90”];<br>NSDecimalNumber *numProducts = [NSDecimalNumber decimalNumberWithString:@”2.0”];   </p><p>NSDecimalNumber <em>subtotal = [price1 decimalNumberByAdding:price2];<br>NSDecimalNumber </em>afterCoupon = [subtotal decimalNumberBySubtracting:coupon];<br>NSDecimalNumber <em>afterDiscount = [afterCoupon decimalNumberByMultiplyingBy:discount];<br>NSDecimalNumber </em>average = [afterDiscount decimalNumberByDividingBy:numProducts];<br>NSDecimalNumber *averageSquared = [average decimalNumberByRaisingToPower:2];   </p><p>打印数值如下：<br>NSLog(@”Subtotal: %@”, subtotal);                    // 45.98 </p><p>NSLog(@”After coupon: %@”, afterCoupon);            // 40.98</p><p>NSLog((@”After discount: %@”), afterDiscount);       // 36.882</p><p>NSLog(@”Average price per product: %@”, average);    // 18.441</p><p>NSLog(@”Average price squared: %@”, averageSquared); // 340.070481</p><p>取正方式<br>上面的没个算式方法都有个扩充的带behavior参数的方法。通过behavior可以对最后的结果进行取正和保留小数个数的限制。你可以自定义behavior：</p><p>// Rounding policies :<br>// Original<br>//value 1.2  1.21  1.25  1.35  1.27<br>// Plain    1.2  1.2   1.3   1.4   1.3  四舍五入<br>// Down     1.2  1.2   1.2   1.3   1.2  向下取正<br>// Up       1.2  1.3   1.3   1.4   1.3  向上取正<br>// Bankers  1.2  1.2   1.2   1.4   1.3  (特殊的四舍五入，碰到保留位数后一位的数字为5时，根据前一位的奇偶性决定。为偶时向下取正，为奇数时向上取正。如：1.25保留1为小数。5之前是2偶数向下取正1.2；1.35保留1位小数时。5之前为3奇数，向上取正1.4）</p><p>  typedef NS_ENUM(NSUInteger, NSRoundingMode) {</p><pre><code>NSRoundPlain,   // Round up on a tieNSRoundDown,    // Always down == truncateNSRoundUp,      // Always upNSRoundBankers  // on a tie round so last digit is even</code></pre><p>  };   </p><p>//scale：保留有效小数的个数（为0的无效小数后自动过滤).<br>//Exactness：进度异常、Overflow:向上溢出、Underflow：向下溢出、DivideByZero：除数为0。当参数为YES出错会抛出异常，为NO时忽略异常。返回nil.<br>NSDecimalNumberHandler *roundUp = [NSDecimalNumberHandler<br>                                   decimalNumberHandlerWithRoundingMode:NSRoundUp<br>                                   scale:2<br>                                   raiseOnExactness:NO<br>                                   raiseOnOverflow:NO<br>                                   raiseOnUnderflow:NO<br>                                   raiseOnDivideByZero:YES];</p><p>PS:NSDecimalNumber同时提供了isEqualToNumber:方法和NSNumber进行判断是否相等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在开发中经常遇到float类型数据转化为NSString再进行显示，但是经常遇到精度出错的问题，如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;float testF = 123.45;
NSString *testStr = [NSString stringWithFormat
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://snsfrontend.crysnower.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>echarts之用饼图制作带labelline的旭日图(一)</title>
    <link href="http://snsfrontend.crysnower.cn/echarts%E7%94%A8%E9%A5%BC%E5%9B%BE%E5%88%B6%E4%BD%9C%E5%B8%A6labelline%E7%9A%84%E6%97%AD%E6%97%A5%E5%9B%BE.html"/>
    <id>http://snsfrontend.crysnower.cn/echarts用饼图制作带labelline的旭日图.html</id>
    <published>2018-05-12T09:04:00.000Z</published>
    <updated>2018-05-21T06:12:06.547Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>如果你想要用较少的代码实现比较酷炫的数据统计表，echarts是值得你考虑的一种实现方式。官网提供了很多实例供参考。并且配置项手册很详细，几乎囊括了所有的绘图需求。但是再全的配置，偶尔也会有不满足需求的时候。最近在开发过程中就遇到了一个比较头疼的问题。<br>先看下UI效果<br><img src="/images/dy20180512171652810.jpg" alt="带labelline的日辉图"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>拿到需求，先看echarts的配置手册，很容易想到使用旭日图来做。<br>但是还没等大致效果出来，坑就来了，旭日图的配置项里面没有labelline，也就是没有指向色环的那根线。</p><p>额。。。咋整</p><p>先百度看看吧，找啊找，还是没有解决方案</p><p>没办法，迷茫了好一会，只能在配置手册里瞎看。。。突然，我看到了这张图</p><p><img src="/images/dy20180512175000465.jpg" alt="带labelline的日辉图"></p><p>灵机一动，是不是可以用饼图来做旭日图呢，只需要把外面一圈不需要的数据设置成透明就行了？</p><h3 id="码代码"><a href="#码代码" class="headerlink" title="码代码"></a>码代码</h3><p>服务端给的数据结构是这样的<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    <span class="attr">"value"</span>: <span class="number">60</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"移动端"</span>,</span><br><span class="line">    <span class="attr">"children"</span>: [&#123;</span><br><span class="line">        <span class="attr">"value"</span>: <span class="number">40</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"苹果"</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">"value"</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"安卓"</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">"value"</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"塞班"</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">"value"</span>: <span class="number">40</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"PC"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">"value"</span>: <span class="number">40</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"平板"</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p><p>我们需要两个data，data0 是内环的数据，这个直接就从数组的第一层获取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data0 = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; originaldata.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = originaldata[i];<span class="comment">//从服务端给的数组中取出数据</span></span><br><span class="line">    data0.push(&#123;</span><br><span class="line">        value: obj.value,</span><br><span class="line">        name: obj.name,</span><br><span class="line">        itemStyle: &#123;</span><br><span class="line">            color: color0[i]</span><br><span class="line">        &#125;,</span><br><span class="line">        labelLine: &#123;</span><br><span class="line">            length: <span class="number">40</span>,</span><br><span class="line">            length2: <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来获取外环的数据 data1<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data1 = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; originaldata.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = originaldata[i];</span><br><span class="line">    <span class="keyword">var</span> kids = obj.children;</span><br><span class="line">    <span class="comment">//没有子数据，直接加入data1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span>(kids) === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        data1.push(&#123;</span><br><span class="line">            value: obj.value,</span><br><span class="line">            name: obj.name,</span><br><span class="line">            <span class="comment">//没有子数据，将其设置为透明</span></span><br><span class="line">            itemStyle: &#123;</span><br><span class="line">                color: <span class="string">'transparent'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; kids.length; k++) &#123;</span><br><span class="line">            <span class="keyword">var</span> kid = kids[k];</span><br><span class="line">            data1.push(&#123;</span><br><span class="line">                value: kid.value,</span><br><span class="line">                name: kid.name,</span><br><span class="line">                itemStyle: &#123;</span><br><span class="line">                    color: color1[k]</span><br><span class="line">                &#125;,</span><br><span class="line">                label: &#123;</span><br><span class="line">                    normal: &#123;</span><br><span class="line">                        position: <span class="string">'outside'</span>,</span><br><span class="line">                        formatter: <span class="string">'&#123;b&#125; &#123;d&#125;% '</span>,</span><br><span class="line">                        color: <span class="string">'#909090'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后在option中设置data0 和 data1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">    backgroundColor: <span class="string">'#161823'</span>,</span><br><span class="line">    series: [&#123;</span><br><span class="line">            name: <span class="string">'访问来源'</span>,</span><br><span class="line">            type: <span class="string">'pie'</span>,<span class="comment">//饼图</span></span><br><span class="line">            animation: <span class="literal">false</span>,</span><br><span class="line">            radius: [<span class="string">'47%'</span>, <span class="string">'74%'</span>],<span class="comment">//内环尺寸</span></span><br><span class="line">            label: &#123;</span><br><span class="line">                normal: &#123;</span><br><span class="line">                    position: <span class="string">'outside'</span>,</span><br><span class="line">                    formatter: <span class="string">'&#123;b&#125; &#123;d&#125;% '</span>,</span><br><span class="line">                    color: <span class="string">'#fff'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            labelLine: &#123;</span><br><span class="line">                normal: &#123;</span><br><span class="line">                    show: <span class="literal">true</span></span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            data: data0</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'访问来源'</span>,</span><br><span class="line">            type: <span class="string">'pie'</span>,</span><br><span class="line">            radius: [<span class="string">'74%'</span>, <span class="string">'84%'</span>],<span class="comment">//外环尺寸</span></span><br><span class="line">            animation: <span class="literal">false</span>,</span><br><span class="line">            data: data1</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="预览地址"><a href="#预览地址" class="headerlink" title="预览地址"></a>预览地址</h3><p><a href="http://gallery.echartsjs.com/editor.html?c=xBJmySVERf&amp;v=1" target="_blank" rel="noopener">http://gallery.echartsjs.com/editor.html?c=xBJmySVERf&amp;v=1</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;如果你想要用较少的代码实现比较酷炫的数据统计表，echarts是值得你考虑的一种实现方式。官网提供了很多实例供参考。并且配置项手册很详细，几
      
    
    </summary>
    
      <category term="WEB" scheme="http://snsfrontend.crysnower.cn/categories/WEB/"/>
    
    
      <category term="echarts" scheme="http://snsfrontend.crysnower.cn/tags/echarts/"/>
    
  </entry>
  
  <entry>
    <title>Android : 监听app后台切换到前台</title>
    <link href="http://snsfrontend.crysnower.cn/%E7%9B%91%E5%90%ACapp%E5%90%8E%E5%8F%B0%E5%88%87%E6%8D%A2%E5%88%B0%E5%89%8D%E5%8F%B0.html"/>
    <id>http://snsfrontend.crysnower.cn/监听app后台切换到前台.html</id>
    <published>2018-05-12T08:46:00.000Z</published>
    <updated>2018-05-20T07:11:48.559Z</updated>
    
    <content type="html"><![CDATA[<p>App后台切换前台可以通过ActivityLifecycleCallbacks方法来实现，ActivityLifecycleCallbacks可以用来监听app中所有Activity的声明周期<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void unRegister(Application application)&#123;</span><br><span class="line">     application.unregisterActivityLifecycleCallbacks(activityLifecycleCallbacks);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> private Application.ActivityLifecycleCallbacks activityLifecycleCallbacks = new Application.ActivityLifecycleCallbacks() &#123;</span><br><span class="line">     //打开的Activity数量统计</span><br><span class="line">     private int activityStartCount = 0;</span><br><span class="line">     </span><br><span class="line">     @Override</span><br><span class="line">     public void onActivityStarted(Activity activity) &#123;</span><br><span class="line">         activityStartCount++;</span><br><span class="line">         //数值从0变到1说明是从后台切到前台</span><br><span class="line">         if (activityStartCount == 1)&#123;</span><br><span class="line">             //从后台切到前台</span><br><span class="line">             if(mOnAppStatusListener != null)&#123;</span><br><span class="line">                 mOnAppStatusListener.onFront();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void onActivityStopped(Activity activity) &#123;</span><br><span class="line">         activityStartCount--;</span><br><span class="line">         //数值从1到0说明是从前台切到后台</span><br><span class="line">         if (activityStartCount == 0)&#123;</span><br><span class="line">             //从前台切到后台</span><br><span class="line">             if(mOnAppStatusListener != null)&#123;</span><br><span class="line">                 mOnAppStatusListener.onBack();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;App后台切换前台可以通过ActivityLifecycleCallbacks方法来实现，ActivityLifecycleCallbacks可以用来监听app中所有Activity的声明周期&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
      
    
    </summary>
    
      <category term="Android" scheme="http://snsfrontend.crysnower.cn/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>计算一年中所有周的第一天和最后一天</title>
    <link href="http://snsfrontend.crysnower.cn/%E8%AE%A1%E7%AE%97%E4%B8%80%E5%B9%B4%E4%B8%AD%E6%89%80%E6%9C%89%E5%91%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9.html"/>
    <id>http://snsfrontend.crysnower.cn/计算一年中所有周的第一天和最后一天.html</id>
    <published>2018-05-07T11:34:00.000Z</published>
    <updated>2018-05-21T06:33:10.636Z</updated>
    
    <content type="html"><![CDATA[<p>准备</p><p>在看代码之前你可能需要先了解以下知识</p><ul><li><p><a href="https://www.jianshu.com/p/d0e56b09179a" target="_blank" rel="noopener">NSDate、NSCalendar和NSDateComponents</a></p></li><li><p><a href="https://blog.csdn.net/awaylin113/article/details/39557969" target="_blank" rel="noopener">NSCalendar使用详解</a></p></li></ul><p>代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - (<span class="keyword">void</span>)weeksWithDateComponents:(<span class="built_in">NSDateComponents</span> *)fromComp</span><br><span class="line">              toDateComponents:(<span class="built_in">NSDateComponents</span> *)toComp&#123;</span><br><span class="line">    <span class="comment">//获取公历日历</span></span><br><span class="line">    <span class="built_in">NSCalendar</span> *calendar = [<span class="built_in">NSCalendar</span> calendarWithIdentifier:<span class="built_in">NSCalendarIdentifierGregorian</span>];</span><br><span class="line">    <span class="comment">//一年中的天数或一年已过的天数</span></span><br><span class="line">    <span class="built_in">NSInteger</span> daysOfYear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (toComp) &#123;<span class="comment">//计算已过的天数</span></span><br><span class="line">        daysOfYear = [calendar ordinalityOfUnit:<span class="built_in">NSCalendarUnitDay</span> inUnit:<span class="built_in">NSCalendarUnitYear</span> forDate:[calendar dateFromComponents:toComp]];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//计算一年的天数</span></span><br><span class="line"><span class="comment">//        daysOfYear = [calendar rangeOfUnit:NSCalendarUnitDay inUnit:NSCalendarUnitYear forDate:[calendar dateFromComponents:fromComp]].length;//在9.3系统里始终是31天</span></span><br><span class="line">        <span class="comment">/*fixed 9.3 bug*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++) &#123;</span><br><span class="line">            fromComp.month = i;</span><br><span class="line">            fromComp.day = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">NSDate</span> *date = [calendar dateFromComponents:fromComp];</span><br><span class="line">            daysOfYear += [calendar rangeOfUnit:<span class="built_in">NSCalendarUnitDay</span> inUnit:<span class="built_in">NSCalendarUnitMonth</span> forDate:date].length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//月份移动至1月</span></span><br><span class="line">    fromComp.month = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//记录当前第几周</span></span><br><span class="line">    <span class="built_in">NSInteger</span> weekOfYear = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历每一天</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">1</span>; i &lt;= daysOfYear; i++) &#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="comment">//移至当前天</span></span><br><span class="line">            fromComp.day = i;</span><br><span class="line">            <span class="built_in">NSDate</span> *idate = [calendar dateFromComponents:fromComp];</span><br><span class="line">            <span class="built_in">NSDateComponents</span> *comp = [calendar components:kCFCalendarUnitDay|kCFCalendarUnitWeekday|kCFCalendarUnitMonth fromDate:idate];</span><br><span class="line">            <span class="comment">//星期一开始算周</span></span><br><span class="line">            <span class="keyword">if</span> (comp.weekday == <span class="number">2</span>) &#123;</span><br><span class="line">                weekOfYear += <span class="number">1</span>;</span><br><span class="line">                fromComp.day = MIN(i+<span class="number">6</span>,daysOfYear);</span><br><span class="line">                <span class="built_in">NSDate</span> *fdate = [calendar dateFromComponents:fromComp];</span><br><span class="line">                <span class="built_in">NSString</span> *reslut = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"第%zd周 (%zd月%zd日-%zd月%zd日)"</span>,weekOfYear,</span><br><span class="line">                                    [calendar ordinalityOfUnit:<span class="built_in">NSCalendarUnitMonth</span> inUnit:<span class="built_in">NSCalendarUnitYear</span> forDate:fdate],</span><br><span class="line">                                    [calendar ordinalityOfUnit:<span class="built_in">NSCalendarUnitDay</span> inUnit:<span class="built_in">NSCalendarUnitMonth</span> forDate:fdate],</span><br><span class="line">                                    [calendar ordinalityOfUnit:<span class="built_in">NSCalendarUnitMonth</span> inUnit:<span class="built_in">NSCalendarUnitYear</span> forDate:idate],</span><br><span class="line">                                    [calendar ordinalityOfUnit:<span class="built_in">NSCalendarUnitDay</span> inUnit:<span class="built_in">NSCalendarUnitMonth</span> forDate:idate]];</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,reslut);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDateComponents</span> * fComp = [[<span class="built_in">NSCalendar</span> currentCalendar] components:<span class="built_in">NSCalendarUnitYear</span>|<span class="built_in">NSCalendarUnitMonth</span>|<span class="built_in">NSCalendarUnitDay</span> fromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">fComp.month = <span class="number">1</span>;</span><br><span class="line">fComp.day = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">NSDateComponents</span> * tComp = [[<span class="built_in">NSCalendar</span> currentCalendar] components:<span class="built_in">NSCalendarUnitYear</span>|<span class="built_in">NSCalendarUnitMonth</span>|<span class="built_in">NSCalendarUnitDay</span> fromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">[<span class="keyword">self</span> weeksWithDateComponents:fComp toDateComponents:tComp];</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;准备&lt;/p&gt;
&lt;p&gt;在看代码之前你可能需要先了解以下知识&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/d0e56b09179a&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NSDate、NSCal
      
    
    </summary>
    
      <category term="IOS开发" scheme="http://snsfrontend.crysnower.cn/categories/IOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="日历" scheme="http://snsfrontend.crysnower.cn/tags/%E6%97%A5%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>关于Masonry的使用和注意点</title>
    <link href="http://snsfrontend.crysnower.cn/%E5%85%B3%E4%BA%8EMasonry%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E6%B3%A8%E6%84%8F%E7%82%B9.html"/>
    <id>http://snsfrontend.crysnower.cn/关于Masonry的使用和注意点.html</id>
    <published>2018-05-07T02:24:40.000Z</published>
    <updated>2018-05-21T06:30:26.961Z</updated>
    
    <content type="html"><![CDATA[<p>因为之前开发时都是在xib文件中添加约束，或者代码中计算frame并没有接触过Masonry，现在写篇博客来归纳总结下Masonry的使用和注意点。这篇文章只是简单介绍Masonry，以及Masonry的使用，并且会举一些例子出来。但并不会涉及到Masonry的内部实现</p><p>Masonry中的坑：</p><p>在使用Masonry进行约束时，有一些是需要注意的。</p><p>在使用Masonry添加约束之前，需要在addSubview之后才能使用，否则会导致崩溃。<br>在添加约束时初学者经常会出现一些错误，约束出现问题的原因一般就是两种：约束冲突和缺少约束。对于这两种问题，可以通过调试和log排查。<br>之前使用Interface Builder添加约束，如果约束有错误直接就可以看出来，并且会以红色或者黄色警告体现出来。而Masonry则不会直观的体现出来，而是以运行过程中崩溃或者打印异常log体现，所以这也是手写代码进行AutoLayout的一个缺点。<br>这个问题只能通过多敲代码，积攒纯代码进行AutoLayout的经验，慢慢就用起来越来越得心应手了。</p><p>Masonry基础使用</p><p>Masonry基础API<br>mas_makeConstraints()    添加约束.<br>mas_remakeConstraints()  移除之前的约束，重新添加新的约束.<br>mas_updateConstraints()  更新约束</p><p>equalTo()       参数是对象类型，一般是视图对象或者mas_width这样的坐标系对象</p><p>mas_equalTo()   和上面功能相同，参数可以传递基础数据类型对象，可以理解为比上面的API更强大</p><p>width()         用来表示宽度，例如代表view的宽度</p><p>mas_width()     用来获取宽度的值。和上面的区别在于，一个代表某个坐标系对象，一个用来获取坐标系对象的值<br>Auto Boxing</p><p>上面例如equalTo或者width这样的，有时候需要涉及到使用mas_前缀，这在开发中需要注意作区分。</p><p>如果在当前类引入#import “Masonry.h”之前，用下面两种宏定义声明一下，就不需要区分mas_前缀。</p><p>// 定义这个常量，就可以不用在开发过程中使用”mas_”前缀。</p><p>#define MAS_SHORTHAND<br>// 定义这个常量，就可以让Masonry帮我们自动把基础数据类型的数据，自动装箱为对象类型。</p><p>#define MAS_SHORTHAND_GLOBALS<br>修饰语句</p><p>Masonry为了让代码使用和阅读更容易理解，所以直接通过点语法就可以调用，还添加了and和with两个方法。这两个方法内部实际上什么都没干，只是在内部将self直接返回，功能就是为了更加方便阅读，对代码执行没有实际作用。</p><p>例如下面的例子：</p><p>make.top.and.bottom.equalTo(self.containerView).with.offset(padding);<br>其内部代码实现，实际上就是直接将self返回。</p><ul><li>(MASConstraint *)with {<br>  return self;<br>}<br>更新约束和布局</li></ul><p>关于更新约束布局相关的API，主要用以下四个API：</p><ul><li>(void)updateConstraintsIfNeeded  调用此方法，如果有标记为需要重新布局的约束，则立即进行重新布局，内部会调用updateConstraints方法</li><li>(void)updateConstraints          重写此方法，内部实现自定义布局过程</li><li>(BOOL)needsUpdateConstraints     当前是否需要重新布局，内部会判断当前有没有被标记的约束</li><li>(void)setNeedsUpdateConstraints  标记需要进行重新布局<br>关于UIView重新布局相关的API，主要用以下三个API：</li></ul><ul><li>(void)setNeedsLayout  标记为需要重新布局</li><li>(void)layoutIfNeeded  查看当前视图是否被标记需要重新布局，有则在内部调用layoutSubviews方法进行重新布局</li><li>(void)layoutSubviews  重写当前方法，在内部完成重新布局操作<br>Masonry示例代码</li></ul><p>Masonry本质上就是对系统AutoLayout进行的封装，包括里面很多的API，都是对系统API进行了一次二次包装。</p><p>typedef NS_OPTIONS(NSInteger, MASAttribute) {</p><pre><code>MASAttributeLeft = 1 &lt;&lt; NSLayoutAttributeLeft,    MASAttributeRight = 1 &lt;&lt; NSLayoutAttributeRight,  MASAttributeTop = 1 &lt;&lt; NSLayoutAttributeTop,   MASAttributeBottom = 1 &lt;&lt; NSLayoutAttributeBottom,  MASAttributeLeading = 1 &lt;&lt; NSLayoutAttributeLeading,  MASAttributeTrailing = 1 &lt;&lt; NSLayoutAttributeTrailing,  MASAttributeWidth = 1 &lt;&lt; NSLayoutAttributeWidth,  MASAttributeHeight = 1 &lt;&lt; NSLayoutAttributeHeight,  MASAttributeCenterX = 1 &lt;&lt; NSLayoutAttributeCenterX,  MASAttributeCenterY = 1 &lt;&lt; NSLayoutAttributeCenterY,  MASAttributeBaseline = 1 &lt;&lt; NSLayoutAttributeBaseline,  </code></pre><p>};<br>常用方法</p><p>设置内边距</p><p>/**<br> 设置yellow视图和self.view等大，并且有10的内边距。<br> 注意根据UIView的坐标系，下面right和bottom进行了取反。所以不能写成下面这样，否则right、bottom这两个方向会出现问题。<br> make.edges.equalTo(self.view).with.offset(10);</p><p> 除了下面例子中的offset()方法，还有针对不同坐标系的centerOffset()、sizeOffset()、valueOffset()之类的方法。<br> <em>/<br>[self.yellowView mas_makeConstraints:^(MASConstraintMaker </em>make) {<br>    make.left.equalTo(self.view).with.offset(10);<br>    make.top.equalTo(self.view).with.offset(10);<br>    make.right.equalTo(self.view).with.offset(-10);<br>    make.bottom.equalTo(self.view).with.offset(-10);<br>}];<br>通过insets简化设置内边距的方式</p><p>// 下面的方法和上面例子等价，区别在于使用insets()方法。<br>[self.blueView mas_makeConstraints:^(MASConstraintMaker *make) {<br>    // 下、右不需要写负号，insets方法中已经为我们做了取反的操作了。<br>    make.edges.equalTo(self.view).with.insets(UIEdgeInsetsMake(10, 10, 10, 10));<br>}];<br>更新约束</p><p>// 设置greenView的center和size，这样就可以达到简单进行约束的目的<br>[self.greenView mas_makeConstraints:^(MASConstraintMaker *make) {<br>    make.center.equalTo(self.view);<br>    // 这里通过mas_equalTo给size设置了基础数据类型的参数，参数为CGSize的结构体<br>    make.size.mas_equalTo(CGSizeMake(300, 300));<br>}];</p><p>// 为了更清楚的看出约束变化的效果，在显示两秒后更新约束。<br>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.f <em> NSEC_PER_SEC)), dispatch_get_main_queue(), ^{<br>    [self.greenView mas_updateConstraints:^(MASConstraintMaker </em>make) {<br>        make.centerX.equalTo(self.view).offset(100);<br>        make.size.mas_equalTo(CGSizeMake(100, 100));<br>    }];<br>});<br>大于等于和小于等于某个值的约束</p><p>[self.textLabel mas_makeConstraints:^(MASConstraintMaker *make) {<br>    make.center.equalTo(self.view);<br>    // 设置宽度小于等于200<br>    make.width.lessThanOrEqualTo(@200);<br>    // 设置高度大于等于10<br>    make.height.greaterThanOrEqualTo(@(10));<br>}];<br>self.textLabel.text = @”这是测试的字符串。能看到1、2、3个步骤，第一步当然是上传照片了，要上传正面近照哦。上传后，网站会自动识别你的面部，如果觉得识别的不准，你还可以手动修改一下。左边可以看到16项修改参数，最上面是整体修改，你也可以根据自己的意愿单独修改某项，将鼠标放到选项上面，右边的预览图会显示相应的位置。”;</p><p>textLabel只需要设置一个属性即可</p><p>self.textLabel.numberOfLines = 0;<br>使用基础数据类型当做参数</p><p>/**<br> 如果想使用基础数据类型当做参数，Masonry为我们提供了”mas_xx”格式的宏定义。<br> 这些宏定义会将传入的基础数据类型转换为NSNumber类型，这个过程叫做封箱(Auto Boxing)。</p><p> “mas_xx”开头的宏定义，内部都是通过MASBoxValue()函数实现的。<br> 这样的宏定义主要有四个，分别是mas_equalTo()、mas_offset()和大于等于、小于等于四个。<br> <em>/<br>[self.redView mas_makeConstraints:^(MASConstraintMaker </em>make) {<br>    make.center.equalTo(self.view);<br>    make.width.mas_equalTo(100);<br>    make.height.mas_equalTo(100);<br>}];<br>设置约束优先级</p><p>/*<em><br> Masonry为我们提供了三个默认的方法，priorityLow()、priorityMedium()、priorityHigh()，这三个方法内部对应着不同的默认优先级。<br> 除了这三个方法，我们也可以自己设置优先级的值，可以通过priority()方法来设置。 </em>/<br>[self.redView mas_makeConstraints:^(MASConstraintMaker *make) {<br>    make.center.equalTo(self.view);<br>    make.width.equalTo(self.view).priorityLow();<br>    make.width.mas_equalTo(20).priorityHigh();<br>    make.height.equalTo(self.view).priority(200);<br>    make.height.mas_equalTo(100).priority(1000);<br>}];</p><p>Masonry也帮我们定义好了一些默认的优先级常量，分别对应着不同的数值，优先级最大数值是1000。<br>static const MASLayoutPriority MASLayoutPriorityRequired = UILayoutPriorityRequired;<br>static const MASLayoutPriority MASLayoutPriorityDefaultHigh = UILayoutPriorityDefaultHigh;<br>static const MASLayoutPriority MASLayoutPriorityDefaultMedium = 500;<br>static const MASLayoutPriority MASLayoutPriorityDefaultLow = UILayoutPriorityDefaultLow;<br>static const MASLayoutPriority MASLayoutPriorityFittingSizeLevel = UILayoutPriorityFittingSizeLevel;<br>设置约束比例</p><p>// 设置当前约束值乘以多少，例如这个例子是redView的宽度是self.view宽度的0.2倍。<br>[self.redView mas_makeConstraints:^(MASConstraintMaker *make) {<br>    make.center.equalTo(self.view);<br>    make.height.mas_equalTo(30);<br>    make.width.equalTo(self.view).multipliedBy(0.2);<br>}];<br>小练习</p><p>子视图等高练习</p><p>/**<br> 下面的例子是通过给equalTo()方法传入一个数组，设置数组中子视图及当前make对应的视图之间等高。</p><p> 需要注意的是，下面block中设置边距的时候，应该用insets来设置，而不是用offset。<br> 因为用offset设置right和bottom的边距时，这两个值应该是负数，所以如果通过offset来统一设置值会有问题。<br> <em>/<br>CGFloat padding = LXZViewPadding;<br>[self.redView mas_makeConstraints:^(MASConstraintMaker </em>make) {<br>    make.left.right.top.equalTo(self.view).insets(UIEdgeInsetsMake(padding, padding, 0, padding));<br>    make.bottom.equalTo(self.blueView.mas_top).offset(-padding);<br>}];</p><p>[self.blueView mas_makeConstraints:^(MASConstraintMaker *make) {<br>    make.left.right.equalTo(self.view).insets(UIEdgeInsetsMake(0, padding, 0, padding));<br>    make.bottom.equalTo(self.yellowView.mas_top).offset(-padding);<br>}];</p><p>/*<em><br> 下面设置make.height的数组是关键，通过这个数组可以设置这三个视图高度相等。其他例如宽度之类的，也是类似的方式。 </em>/<br>[self.yellowView mas_makeConstraints:^(MASConstraintMaker *make) {<br>    make.left.right.bottom.equalTo(self.view).insets(UIEdgeInsetsMake(0, padding, padding, padding));<br>    make.height.equalTo(@[self.blueView, self.redView]);<br>}];<br>子视图垂直居中练习</p><p>/*<em><br> 要求：(这个例子是在其他人博客里看到的，然后按照要求自己写了下面这段代码)<br> 两个视图相对于父视图垂直居中，并且两个视图以及父视图之间的边距均为10，高度为150，两个视图宽度相等。 </em>/<br>CGFloat padding = 10.f;<br>[self.blueView mas_makeConstraints:^(MASConstraintMaker *make) {<br>    make.centerY.equalTo(self.view);<br>    make.left.equalTo(self.view).mas_offset(padding);<br>    make.right.equalTo(self.redView.mas_left).mas_offset(-padding);<br>    make.width.equalTo(self.redView);<br>    make.height.mas_equalTo(150);<br>}];</p><p>[self.redView mas_makeConstraints:^(MASConstraintMaker *make) {<br>    make.centerY.equalTo(self.view);<br>    make.right.equalTo(self.view).mas_offset(-padding);<br>    make.width.equalTo(self.blueView);<br>    make.height.mas_equalTo(150);<br>}];<br>UITableView动态Cell高度</p><p>在iOS UI开发过程中，UITableView的动态Cell高度一直都是个问题。实现这样的需求，实现方式有很多种，只是实现起来复杂程度和性能的区别。</p><p>在不考虑性能的情况下，tableView动态Cell高度，可以采取估算高度的方式。如果通过估算高度的方式实现的话，无论是纯代码还是Interface Builder，都只需要两行代码就可以完成Cell自动高度适配。</p><p>实现方式：</p><p>需要设置tableView的rowHeight属性，这里设置为自动高度，告诉系统Cell的高度是不固定的，需要系统帮我们进行计算。然后设置tableView的estimatedRowHeight属性，设置一个估计的高度。(我这里用的代理方法，实际上都一样)</p><p>原理：</p><p>这样的话，在tableView被创建之后，系统会根据estimatedRowHeight属性设置的值，为tableView设置一个估计的值。然后在Cell显示的时候再获取Cell的高度，并刷新tableView的contentSize。</p><ul><li><p>(void)tableViewConstraints {<br>  [self.tableView mas_makeConstraints:^(MASConstraintMaker *make) {</p><pre><code>make.edges.equalTo(self.view);</code></pre><p>  }];<br>}</p></li><li><p>(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {<br>  return self.dataList.count;<br>}</p></li><li><p>(MasonryTableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath <em>)indexPath {<br>  MasonryTableViewCell </em>cell = [tableView dequeueReusableCellWithIdentifier:LXZTableViewCellIdentifier];<br>  [cell reloadViewWithText:self.dataList[indexPath.row]];<br>  return cell;<br>}</p></li></ul><p>// 需要注意的是，这个代理方法和直接返回当前Cell高度的代理方法并不一样。<br>// 这个代理方法会将当前所有Cell的高度都预估出来，而不是只计算显示的Cell，所以这种方式对性能消耗还是很大的。<br>// 所以通过设置estimatedRowHeight属性的方式，和这种代理方法的方式，最后性能消耗都是一样的。</p><ul><li><p>(CGFloat)tableView:(UITableView <em>)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath </em>)indexPath {<br>  return 50.f;<br>}</p></li><li><p>(UITableView *)tableView {<br>  if (!_tableView) {</p><pre><code>_tableView = [[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStylePlain];_tableView.delegate = self;_tableView.dataSource = self;// 设置tableView自动高度_tableView.rowHeight = UITableViewAutomaticDimension;[_tableView registerClass:[MasonryTableViewCell class] forCellReuseIdentifier:LXZTableViewCellIdentifier];[self.view addSubview:_tableView];</code></pre><p>  }<br>  return _tableView;<br>}<br>UIScrollView自动布局</p></li></ul><p>之前听很多人说过UIScrollView很麻烦，然而我并没有感觉到有多麻烦(并非装逼)。我感觉说麻烦的人可能根本就没试过吧，只是觉得很麻烦而已。</p><p>我这里就讲一下两种进行UIScrollView自动布局的方案，并且会讲一下自动布局的技巧，只要掌握技巧，布局其实很简单。</p><p>布局小技巧：</p><p>给UIScrollView添加的约束是定义其frame，设置contentSize是定义其内部大小。UIScrollView进行addSubview操作，都是将其子视图添加到contentView上。</p><p>所以，添加到UIScrollView上的子视图，对UIScrollView添加的约束都是作用于contentView上的。只需要按照这样的思路给UIScrollView设置约束，就可以掌握设置约束的技巧了。</p><p>提前设置contentSize</p><p>// 提前设置好UIScrollView的contentSize，并设置UIScrollView自身的约束<br>self.scrollView.contentSize = CGSizeMake(1000, 1000);<br>[self.scrollView mas_makeConstraints:^(MASConstraintMaker *make) {<br>    make.edges.equalTo(self.view);<br>}];</p><p>// 虽然redView的get方法内部已经执行过addSubview操作，但是UIView始终以最后一次添加的父视图为准，也就是redView始终是在最后一次添加的父视图上。<br>[self.scrollView addSubview:self.redView];<br>[self.redView mas_makeConstraints:^(MASConstraintMaker *make) {<br>    make.left.top.equalTo(self.scrollView);<br>    make.width.height.mas_equalTo(200);<br>}];</p><p>[self.scrollView addSubview:self.blueView];<br>[self.blueView mas_makeConstraints:^(MASConstraintMaker *make) {<br>    make.left.equalTo(self.redView.mas_right);<br>    make.top.equalTo(self.scrollView);<br>    make.width.height.equalTo(self.redView);<br>}];</p><p>[self.scrollView addSubview:self.greenView];<br>[self.greenView mas_makeConstraints:^(MASConstraintMaker *make) {<br>    make.left.equalTo(self.scrollView);<br>    make.top.equalTo(self.redView.mas_bottom);<br>    make.width.height.equalTo(self.redView);<br>}];<br>自动contentSize</p><p>上面的例子是提前设置好UIScrollView的contentSize的内部size，然后直接向里面addSubview。但是这有个要求就是，需要提前知道contentSize的大小，不然没法设置。</p><p>这个例子中将会展示动态改变contentSize的大小，内部视图有多少contentSize就自动扩充到多大。</p><p>这种方式的实现，主要是依赖于创建一个containerView内容视图，并添加到UIScrollView上作为子视图。UIScrollView原来的子视图都添加到containerView上，并且和这个视图设置约束。</p><p>因为对UIScrollView进行addSubview操作的时候，本质上是往其contentView上添加。也就是containerView的父视图是contentView，通过containerView撑起contentView视图的大小，以此来实现动态改变contentSize。</p><p>// 在进行约束的时候，要对containerView的上下左右都添加和子视图的约束，以便确认containerView的边界区域。<br>[self.scrollView mas_makeConstraints:^(MASConstraintMaker *make) {<br>    make.edges.equalTo(self.view);<br>}];</p><p>CGFloat padding = LXZViewPadding;<br>[self.containerView mas_makeConstraints:^(MASConstraintMaker *make) {<br>    make.edges.equalTo(self.scrollView).insets(UIEdgeInsetsMake(padding, padding, padding, padding));<br>}];</p><p>[self.containerView addSubview:self.greenView];<br>[self.greenView mas_makeConstraints:^(MASConstraintMaker *make) {<br>    make.top.left.equalTo(self.containerView).offset(padding);<br>    make.size.mas_equalTo(CGSizeMake(250, 250));<br>}];</p><p>[self.containerView addSubview:self.redView];<br>[self.redView mas_makeConstraints:^(MASConstraintMaker *make) {<br>    make.top.equalTo(self.containerView).offset(padding);<br>    make.left.equalTo(self.greenView.mas_right).offset(padding);<br>    make.size.equalTo(self.greenView);<br>    make.right.equalTo(self.containerView).offset(-padding);<br>}];</p><p>[self.containerView addSubview:self.yellowView];<br>[self.yellowView mas_makeConstraints:^(MASConstraintMaker *make) {<br>    make.left.equalTo(self.containerView).offset(padding);<br>    make.top.equalTo(self.greenView.mas_bottom).offset(padding);<br>    make.size.equalTo(self.greenView);<br>    make.bottom.equalTo(self.containerView).offset(-padding);<br>}];</p><p>多个（2个以上）控件的等间隔排序显示<br>首先介绍2个函数<br>/** </p><pre><code>*  axisType         轴线方向 *  fixedSpacing     间隔大小 *  fixedItemLength  每个控件的固定长度/宽度 *  leadSpacing      头部间隔 *  tailSpacing      尾部间隔 * */  </code></pre><p>//1. 等间隔排列 - 多个控件间隔固定，控件长度/宽度变化  </p><ul><li>(void)mas_distributeViewsAlongAxis:(MASAxisType)axisType<br>withFixedSpacing:(CGFloat)fixedSpacing leadSpacing:(CGFloat)leadSpacing<br>tailSpacing:(CGFloat)tailSpacing;  </li></ul><p>//2. 等间隔排列 - 多个固定大小固定，间隔空隙变化  </p><ul><li>(void)mas_distributeViewsAlongAxis:(MASAxisType)axisType<br>withFixedItemLength:(CGFloat)fixedItemLength<br>leadSpacing:(CGFloat)leadSpacing<br>tailSpacing:(CGFloat)tailSpacing;  </li></ul><p>//首先添加5个视图<br> NSMutableArray <em>array = [NSMutableArray new];<br>    for (int i = 0; i &lt; 5; i ++) {<br>        UIView </em>view = [UIView new];<br>        view.backgroundColor = [UIColor greenColor];<br>        [self addSubview:view];<br>        [array addObject:view]; //保存添加的控件<br>    }  </p><p>//水平方向控件间隔固定等间隔<br>[array mas_distributeViewsAlongAxis:MASAxisTypeHorizontal withFixedSpacing:15 leadSpacing:10 tailSpacing:10];<br>            [array makeConstraints:^(MASConstraintMaker *make) {<br>                make.top.equalTo(50);<br>                make.height.equalTo(70);<br>            }];  </p><p>//水平方向宽度固定等间隔<br>[array mas_distributeViewsAlongAxis:MASAxisTypeHorizontal withFixedItemLength:70 leadSpacing:10 tailSpacing:10];<br>            [array makeConstraints:^(MASConstraintMaker *make) { //数组额你不必须都是view<br>                make.top.equalTo(50);<br>                make.height.equalTo(70);<br>            }];  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为之前开发时都是在xib文件中添加约束，或者代码中计算frame并没有接触过Masonry，现在写篇博客来归纳总结下Masonry的使用和注意点。这篇文章只是简单介绍Masonry，以及Masonry的使用，并且会举一些例子出来。但并不会涉及到Masonry的内部实现&lt;/
      
    
    </summary>
    
      <category term="iOS" scheme="http://snsfrontend.crysnower.cn/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>在MKMapView中添加渐变色路径</title>
    <link href="http://snsfrontend.crysnower.cn/%E5%9C%A8MKMapView%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%B8%90%E5%8F%98%E8%89%B2%E8%B7%AF%E5%BE%84.html"/>
    <id>http://snsfrontend.crysnower.cn/在MKMapView中添加渐变色路径.html</id>
    <published>2018-04-28T09:50:37.000Z</published>
    <updated>2018-04-28T10:16:53.129Z</updated>
    
    <content type="html"><![CDATA[<p>刚来苏宁接触到的业务并不多，既然要写博客那就暂时上一篇之前所遇到的关于在地图控件中如何添加渐变色路径实现方案吧。</p><p>整体实现原理是依据用户跑步配速将坐标点等分为若干色块，将色块相连就形成了渐变色轨迹</p><p>如何在iPhone上绘制mapView就不说了，在mapView上绘制轨迹要添加MKPolyline，调用[self.mapView addOverlay:self.polyLine]；但这个MKPolyline的构造方法中只接受和坐标相关的值，而轨迹渐变自然要通过速度控制，但传不进去，所以只能重写一个实现<mkoverlay>协议的类。下面就是我找到的，拿去可以直接用：</mkoverlay></p><p>GradientPolylineOverlay.h实现</p><p>#import &lt;Foundation/Foundation.h&gt;</p><p>#import &lt;MapKit/MapKit.h&gt;</p><p>@interface GradientPolylineOverlay : NSObject <mkoverlay>{<br>    MKMapPoint *points;<br>    NSUInteger pointCount;<br>    NSUInteger pointSpace;</mkoverlay></p><pre><code>MKMapRect boundingMapRect;pthread_rwlock_t rwLock;</code></pre><p>}</p><p>//Initialize the overlay with the starting coordinate.<br>//The overlay’s boundingMapRect will be set to a sufficiently large square<br>//centered on the starting coordinate.<br>-(id) initWithCenterCoordinate:(CLLocationCoordinate2D)coord;</p><p>-(id) initWithPoints:(CLLocationCoordinate2D<em>)_points velocity:(float</em>)_velocity count:(NSUInteger)_count;</p><p>//Add a location observation. A MKMapRect containing the newly added point<br>//and the previously added point is returned so that the view can be updated<br>//int that rectangle. If the added coordinate has not moved far enough from<br>//the previously added coordinate it will not be added to the list and<br>//MKMapRectNULL will be returned.<br>//<br>-(MKMapRect)addCoordinate:(CLLocationCoordinate2D)coord;</p><p>-(void) lockForReading;</p><p>//The following properties must only be accessed when holding the read lock<br>// via lockForReading. Once you’re done accessing the points, release the<br>// read lock with unlockForReading.<br>//<br>@property (assign) MKMapPoint <em>points;<br>@property (readonly) NSUInteger pointCount;<br>@property (assign) float </em>velocity;</p><p>-(void) unlockForReading;</p><p>@end<br>GradientPolylineOverlay.m</p><p>#import “GradientPolylineOverlay.h”</p><p>#import &lt;pthread.h&gt;</p><p>#define INITIAL_POINT_SPACE 1000</p><p>#define MINIMUM_DELTA_METERS 10.0</p><p>@implementation GradientPolylineOverlay{<br>}</p><p>@synthesize points, pointCount, velocity;</p><p>-(id) initWithCenterCoordinate:(CLLocationCoordinate2D)coord{<br>    self = [super init];<br>    if (self){<br>        //initialize point storage and place this first coordinate in it<br>        pointSpace = INITIAL_POINT_SPACE;<br>        points = malloc(sizeof(MKMapPoint)*pointSpace);<br>        points[0] = MKMapPointForCoordinate(coord);<br>        pointCount = 1;</p><pre><code>    //bite off up to 1/4 of the world to draw into    MKMapPoint origin = points[0];    origin.x -= MKMapSizeWorld.width/8.0;    origin.y -= MKMapSizeWorld.height/8.0;    MKMapSize size = MKMapSizeWorld;    size.width /=4.0;    size.height /=4.0;    boundingMapRect = (MKMapRect) {origin, size};    MKMapRect worldRect = MKMapRectMake(0, 0, MKMapSizeWorld.width, MKMapSizeWorld.height);    boundingMapRect = MKMapRectIntersection(boundingMapRect, worldRect);    // initialize read-write lock for drawing and updates    pthread_rwlock_init(&amp;rwLock,NULL);}return self;</code></pre><p>}</p><p>-(id) initWithPoints:(CLLocationCoordinate2D<em>)_points velocity:(float </em>)_velocity count:(NSUInteger)_count{<br>    self = [super init];<br>    if (self){<br>        pointCount = _count;<br>        self.points = malloc(sizeof(MKMapPoint)*pointCount);<br>        for (int i=0; i&lt;_count; i++){<br>            self.points[i] = MKMapPointForCoordinate(_points[i]);<br>        }</p><pre><code>    self.velocity = malloc(sizeof(float)*pointCount);    for (int i=0; i&lt;_count;i++){        self.velocity[i] = _velocity[i];    }    //bite off up to 1/4 of the world to draw into    MKMapPoint origin = points[0];    origin.x -= MKMapSizeWorld.width/8.0;    origin.y -= MKMapSizeWorld.height/8.0;    MKMapSize size = MKMapSizeWorld;    size.width /=4.0;    size.height /=4.0;    boundingMapRect = (MKMapRect) {origin, size};    MKMapRect worldRect = MKMapRectMake(0, 0, MKMapSizeWorld.width, MKMapSizeWorld.height);    boundingMapRect = MKMapRectIntersection(boundingMapRect, worldRect);    // initialize read-write lock for drawing and updates    pthread_rwlock_init(&amp;rwLock,NULL);}return self;</code></pre><p>}</p><p>-(void)dealloc{<br>    free(points);<br>    free(velocity);<br>    pthread_rwlock_destroy(&amp;rwLock);<br>}</p><p>//center<br>-(CLLocationCoordinate2D)coordinate{<br>    return MKCoordinateForMapPoint(points[0]);<br>}</p><p>-(MKMapRect)boundingMapRect{<br>    return boundingMapRect;<br>}</p><p>-(void) lockForReading{<br>    pthread_rwlock_rdlock(&amp;rwLock);<br>}</p><p>-(void) unlockForReading{<br>    pthread_rwlock_unlock(&amp;rwLock);<br>}</p><p>-(MKMapRect)addCoordinate:(CLLocationCoordinate2D)coord{<br>    //Acquire the write lock because we are going to changing the list of points<br>    pthread_rwlock_wrlock(&amp;rwLock);</p><pre><code>//Convert a CLLocationCoordinate2D to an MKMapPointMKMapPoint newPoint = MKMapPointForCoordinate(coord);MKMapPoint prevPoint = points[pointCount-1];//Get the distance between this new point and previous pointCLLocationDistance metersApart = MKMetersBetweenMapPoints(newPoint, prevPoint);MKMapRect updateRect = MKMapRectNull;if (metersApart &gt; MINIMUM_DELTA_METERS){    //Grow the points array if necessary    if (pointSpace == pointCount){        pointSpace *= 2;        points = realloc(points, sizeof(MKMapPoint) * pointSpace);    }    //Add the new point to points array    points[pointCount] = newPoint;    pointCount++;    //Compute MKMapRect bounding prevPoint and newPoint    double minX = MIN(newPoint.x,prevPoint.x);    double minY = MIN(newPoint.y,prevPoint.y);    double maxX = MAX(newPoint.x, prevPoint.x);    double maxY = MAX(newPoint.y, prevPoint.y);    updateRect = MKMapRectMake(minX, minY, maxX - minX, maxY - minY);}pthread_rwlock_unlock(&amp;rwLock);return updateRect;</code></pre><p>}</p><p>@end</p><p>下面是在mapview上添加PolyLine的方法：([self smoothTrack] 是我针对项目需求做速度平滑渐变的算法，可以忽略；我绘制轨迹的坐标数据结构是由精度、维度、速度构成的字典；最后添加的方法是调用mapview的分类中的方法，所以有级别，也是根我需求相关，可直接用[self.mapView addOverlay:self.polyline] 代替)</p><p>NSMutableArray <em>smoothTrackArray = [self smoothTrack];<br>    double count = smoothTrackArray.count;<br>    CLLocationCoordinate2D </em>points;<br>    float <em>velocity;<br>    points = malloc(sizeof(CLLocationCoordinate2D)</em>count);<br>    velocity = malloc(sizeof(float)*count);</p><pre><code>for(int i=0;i&lt;count;i++){    NSDictionary *dic = [smoothTrackArray objectAtIndex:i];    CLLocationDegrees latitude  = [dic[@&quot;latitude&quot;] doubleValue];    CLLocationDegrees longitude = [dic[@&quot;longitude&quot;] doubleValue];    CLLocationCoordinate2D coordinate = CLLocationCoordinate2DMake(latitude, longitude);    velocity[i] = [dic[@&quot;speed&quot;] doubleValue];    points[i] = coordinate;}self.polyline = [[GradientPolylineOverlay alloc] initWithPoints:points velocity:velocity count:count];[self.mapView addOverlay:self.polyline level:1];</code></pre><p>轨迹添加好了，还需要在渲染器上面呈现，会调用Mapkit相应的代理：(GradientPolylineRenderer 则是与之对应的渲染器)</p><p>#pragma mark -</p><p>#pragma mark - MKMap Delegate</p><ul><li>(MKOverlayRenderer <em>)mapView:(MKMapView </em>)mapView rendererForOverlay:(id <mkoverlay>)overlay{<br>  if([overlay isKindOfClass:[GradientPolylineOverlay class]]){<pre><code>//轨迹GradientPolylineRenderer *polylineRenderer = [[GradientPolylineRenderer alloc] initWithOverlay:overlay];polylineRenderer.lineWidth = 8.f;return polylineRenderer;</code></pre>  }<br>  return nil;<br>}<br>GradientPolylineRenderer.h实现：</mkoverlay></li></ul><p>#import &lt;MapKit/MapKit.h&gt;</p><p>@interface GradientPolylineRenderer : MKOverlayPathRenderer</p><p>@end<br>GradientPolylineRenderer.m实现：(上面的几个宏定义，是速度的边界值，以及对应的颜色边界值；另外我这里会对hues[i]是否为0做判断，项目需求要区分暂停点和速度过快点，已防作弊，此种情况会用虚线代替，如果只绘制渐变实线，不用管这)</p><p>#import “GradientPolylineRenderer.h”</p><p>#import &lt;pthread.h&gt;</p><p>#import “GradientPolylineOverlay.h”</p><p>#import “Constant.h”</p><p>#define V_MAX 4.5</p><p>#define V_MIN 1.0</p><p>#define H_MAX 0.33</p><p>#define H_MIN 0.03</p><p>@implementation GradientPolylineRenderer{<br>    float<em> hues;<br>    pthread_rwlock_t rwLock;<br>    GradientPolylineOverlay</em> polyline;<br>}</p><ul><li>(id) initWithOverlay:(id<mkoverlay>)overlay{<br>  self = [super initWithOverlay:overlay];<br>  if (self){<pre><code>pthread_rwlock_init(&amp;rwLock,NULL);polyline = ((GradientPolylineOverlay*)self.overlay);float *velocity = polyline.velocity;int count = (int)polyline.pointCount;[self velocity:velocity ToHue:&amp;hues count:count];[self createPath];</code></pre>  }<br>  return self;<br>}<br>/**<ul><li>Convert velocity to Hue using specific formular.<br>*</li><li>H(v) = Hmax, (v &gt; Vmax)</li><li>= Hmin + ((v-Vmin)*(Hmax-Hmin))/(Vmax-Vmin), (Vmin &lt;= v &lt;= Vmax)</li><li>= Hmin, (v &lt; Vmin)<br>*</li><li>@param velocity Velocity list.</li><li>@param count    count of velocity list.<br>*</li><li>@return An array of hues mapping each velocity.<br>*/</li></ul></mkoverlay></li><li><p>(void) velocity:(float<em>)velocity ToHue:(float**)_hue count:(int)count{  </em>_hue = malloc(sizeof(float)*count);<br>  for (int i=0;i&lt;count;i++){</p><pre><code>float curVelo = velocity[i];</code></pre><p>//        //原有渐变公式<br>//        curVelo = ((curVelo &lt; V_MIN) ? V_MIN : (curVelo  &gt; V_MAX) ? V_MAX : curVelo);<br>//        (<em>_hue)[i] = H_MIN + ((curVelo-V_MIN)</em>(H_MAX-H_MIN))/(V_MAX-V_MIN);</p><pre><code>if(curVelo&gt;0.){    curVelo = ((curVelo &lt; V_MIN) ? V_MIN : (curVelo  &gt; V_MAX) ? V_MAX : curVelo);    (*_hue)[i] = H_MIN + ((curVelo-V_MIN)*(H_MAX-H_MIN))/(V_MAX-V_MIN);}else{    //暂停颜色    (*_hue)[i] = 0.;}</code></pre><p>  }<br>}</p></li></ul><p>-(void) createPath{<br>    CGMutablePathRef path = CGPathCreateMutable();<br>    BOOL pathIsEmpty = YES;<br>    for (int i=0;i&lt; polyline.pointCount;i++){<br>        CGPoint point = [self pointForMapPoint:polyline.points[i]];<br>        if (pathIsEmpty){<br>            CGPathMoveToPoint(path, nil, point.x, point.y);<br>            pathIsEmpty = NO;<br>        } else {<br>            CGPathAddLineToPoint(path, nil, point.x, point.y);<br>        }<br>    }</p><pre><code>pthread_rwlock_wrlock(&amp;rwLock);self.path = path; //&lt;—— don&apos;t forget this line.pthread_rwlock_unlock(&amp;rwLock);</code></pre><p>}</p><p>//-(BOOL)canDrawMapRect:(MKMapRect)mapRect zoomScale:(MKZoomScale)zoomScale{<br>//    CGRect pointsRect = CGPathGetBoundingBox(self.path);<br>//    CGRect mapRectCG = [self rectForMapRect:mapRect];<br>//    return CGRectIntersectsRect(pointsRect, mapRectCG);<br>//}</p><ul><li><p>(void) drawMapRect:(MKMapRect)mapRect zoomScale:(MKZoomScale)zoomScale inContext:(CGContextRef)context{</p><p>  //put this blok into the canDraw method cause problem<br>  CGRect pointsRect = CGPathGetBoundingBox(self.path);<br>  CGRect mapRectCG = [self rectForMapRect:mapRect];<br>  if (!CGRectIntersectsRect(pointsRect, mapRectCG))return;<br>  CGContextSetLineCap(context, kCGLineCapRound);<br>  CGContextSetLineJoin(context, kCGLineJoinRound);<br>  UIColor<em> pcolor,</em>ccolor;<br>  for (int i=0;i&lt; polyline.pointCount;i++){</p><pre><code>CGPoint point = [self pointForMapPoint:polyline.points[i]];CGMutablePathRef path = CGPathCreateMutable();if(hues[i]==0.){    //虚线    if(i==0){        CGPathMoveToPoint(path, nil, point.x, point.y);    }else{        //颜色        CGContextSetRGBStrokeColor(context, 153.0 / 255.0, 153.0 / 255.0, 153.0 / 255.0, 1.0);        //线宽        CGFloat lineWidth = CGContextConvertSizeToUserSpace(context, (CGSize){self.lineWidth,self.lineWidth}).width;        CGContextSetLineWidth(context, lineWidth);        CGFloat lengths[] = {lineWidth*2,lineWidth*2};//设置虚线        CGContextSetLineDash(context, lineWidth, lengths, 2);//设置虚线        CGPoint prevPoint = [self pointForMapPoint:polyline.points[i-1]];        CGPathMoveToPoint(path, nil, prevPoint.x, prevPoint.y);        CGPathAddLineToPoint(path, nil, point.x, point.y);        CGContextAddPath(context, path);        CGContextStrokePath(context);    }}else{    //跑步渐变    ccolor = [UIColor colorWithHue:hues[i] saturation:1.0f brightness:1.0f alpha:1.0f];    if (i==0){        CGPathMoveToPoint(path, nil, point.x, point.y);    } else {        CGPoint prevPoint = [self pointForMapPoint:polyline.points[i-1]];        CGPathMoveToPoint(path, nil, prevPoint.x, prevPoint.y);        CGPathAddLineToPoint(path, nil, point.x, point.y);        CGFloat pc_r,pc_g,pc_b,pc_a,        cc_r,cc_g,cc_b,cc_a;        [pcolor getRed:&amp;pc_r green:&amp;pc_g blue:&amp;pc_b alpha:&amp;pc_a];        [ccolor getRed:&amp;cc_r green:&amp;cc_g blue:&amp;cc_b alpha:&amp;cc_a];        CGFloat gradientColors[8] = {pc_r,pc_g,pc_b,pc_a,            cc_r,cc_g,cc_b,cc_a};        CGFloat gradientLocation[2] = {0,1};        CGContextSaveGState(context);        CGFloat lineWidth = CGContextConvertSizeToUserSpace(context, (CGSize){self.lineWidth,self.lineWidth}).width;        CGPathRef pathToFill = CGPathCreateCopyByStrokingPath(path, NULL, lineWidth, self.lineCap, self.lineJoin, self.miterLimit);        CGContextAddPath(context, pathToFill);        CGContextClip(context);        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();        CGGradientRef gradient = CGGradientCreateWithColorComponents(colorSpace, gradientColors, gradientLocation, 2);        CGColorSpaceRelease(colorSpace);        CGPoint gradientStart = prevPoint;        CGPoint gradientEnd = point;        CGContextDrawLinearGradient(context, gradient, gradientStart, gradientEnd, kCGGradientDrawsAfterEndLocation);        CGGradientRelease(gradient);        CGContextRestoreGState(context);        pcolor = [UIColor colorWithCGColor:ccolor.CGColor];    }}</code></pre><p>  }<br>}<br>@end</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚来苏宁接触到的业务并不多，既然要写博客那就暂时上一篇之前所遇到的关于在地图控件中如何添加渐变色路径实现方案吧。&lt;/p&gt;
&lt;p&gt;整体实现原理是依据用户跑步配速将坐标点等分为若干色块，将色块相连就形成了渐变色轨迹&lt;/p&gt;
&lt;p&gt;如何在iPhone上绘制mapView就不说了，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>IOS音视频分片缓存库IdiotAVPlayer</title>
    <link href="http://snsfrontend.crysnower.cn/IOS%E9%9F%B3%E8%A7%86%E9%A2%91%E5%88%86%E7%89%87%E7%BC%93%E5%AD%98%E5%BA%93IdiotAVPlayer.html"/>
    <id>http://snsfrontend.crysnower.cn/IOS音视频分片缓存库IdiotAVPlayer.html</id>
    <published>2018-04-28T09:07:00.000Z</published>
    <updated>2018-05-21T06:19:56.823Z</updated>
    
    <content type="html"><![CDATA[<p>boss让我写博客，说能装X，我就来了！！！☺️</p><p>这篇文章最先发布在简书上，今天先拿过来做开山篇。</p><p>额~~文采不好，不知道怎么写</p><p>来吧，直接切入正题，给大家看看效果吧，免得不是大家想要的东西，浪费大家的宝贵时间。<br><img src="/images/9724987-ce428f8e23f1ec53.gif" alt="IdiotAVPlayer 效果图"><br>本来想给大家看视频的，但是不知道怎么放，哈哈哈。</p><p>再来看IdiotAVplayer实现了什么功能吧。</p><p>相信大家看完上面的图片，大概就知道IdiotAVplayer实现了怎样的功能了，主要就是在选择时间后（seek操作），之前加载的部分会被保存，下次打开会按需加载。本地有数据就从本地取，没有就从网络取（前提是服务器支持Rang，不然没法获取指定区间的数据）。目前为止，网上最多的关于缓存的文章就是AVAssetResourceLoader，但是绝大多数不能再seek动作之后继续缓存，每次seek之后整个音视频就从seek的时间开始了，seek之前的都作废。那么怎么才能实现一个分片缓存的播放器呢？</p><p>目前为止，就我搜索到的开源框架有唱吧团队提供的 KTVHTTPCache（可能还有其他的），是不错。但是它很重，不够轻量。下面引用下唱吧github文章的一段</p><pre><code>方案演进在音视频缓存上，我们一共采用过如下 4 个方案：AVPlayer 纯在线播放。AVPlayer + AVAssetResourceLoader + 下载模块。AVPlayer + 一个开源的缓存项目（同样基于 AVAssetResourceLoader + 下载模块）。AVPlayer + KTVHTTPCache。方案 1 简单直接，缺点也不必多说。方案 2 的下载模块设计的比较简单，只能顺序下载，不支持分片。导致只能 Seek 到已下载完的地方，在用户体验上会有较大的缺陷。方案 3 在功能上已经可以满足需求，但在使用中问题较多，我们在源码基础上做了很多修改来填坑。但稳定性依然不是很理想，上线不长时间就将该功能下掉了。方案 4 是唱吧现在的线上方案，目前在我们的使用场景中还没有发现问题。除稳定性的提升外，比较大的改进是增加了全路径的 Log 模块。若用户或测试同学遇到问题，只需简单描述并回传 Log，就可以快速定位到原因，大大提高了调试效率。</code></pre><p>既然觉得唱吧框架很重，那就去寻求比较轻量级的解决方案。因为我开发的app也是重音视频业务的。造个轮子出来是一劳永逸的事情。</p><p>方案一是纯在线，略过。</p><p>方案二就是大家熟知的AVPlayer + AVAssetResourceLoader。这里我思考了下，既然通过自己的加载方式把数据返回给了AVAssetResourceLoader，那么就应该有办法保存那些已经下载的数据（IdiotAVPlayer就是基于这么个方案）。</p><p>原理图（不会画，将就着看吧）<br><img src="/images/9724987-5e2ca99d7359df7e.png" alt="不会画，将就着看吧"></p><p>（有朋友反映，有些视频下载不下来，不知道是不是网络问题，还是视频格式问题，我也不懂啊，后面请教我boss 哈哈😝）</p><p>好了，今天先装到这里吧</p><p><a href="https://github.com/nikolamht/IdiotAVPlayer" target="_blank" rel="noopener">代码</a></p><p>待续（其实我也不知道有没有后续）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;boss让我写博客，说能装X，我就来了！！！☺️&lt;/p&gt;
&lt;p&gt;这篇文章最先发布在简书上，今天先拿过来做开山篇。&lt;/p&gt;
&lt;p&gt;额~~文采不好，不知道怎么写&lt;/p&gt;
&lt;p&gt;来吧，直接切入正题，给大家看看效果吧，免得不是大家想要的东西，浪费大家的宝贵时间。&lt;br&gt;&lt;img s
      
    
    </summary>
    
      <category term="iOS" scheme="http://snsfrontend.crysnower.cn/categories/iOS/"/>
    
    
      <category term="边下边播" scheme="http://snsfrontend.crysnower.cn/tags/%E8%BE%B9%E4%B8%8B%E8%BE%B9%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>玩转表格：在android上使用ECharts</title>
    <link href="http://snsfrontend.crysnower.cn/%E7%8E%A9%E8%BD%AC%E8%A1%A8%E6%A0%BC%EF%BC%9A%E5%9C%A8android%E4%B8%8A%E4%BD%BF%E7%94%A8ECharts.html"/>
    <id>http://snsfrontend.crysnower.cn/玩转表格：在android上使用ECharts.html</id>
    <published>2018-04-28T07:56:00.000Z</published>
    <updated>2018-05-20T07:19:13.341Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>支持原创，转载请注明出处</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>做Android开发经常会需要画一些图表，自己写的话不仅麻烦而且工作量太大，所以一般都会采用第三方图表框架，现在给大家介绍一款功能非常丰富的图表框架 <a href="http://echarts.baidu.com/index.html" target="_blank" rel="noopener">ECharts</a> 。</p><p>#准备<br>ECharts 是由百度开发提供的开源框架，主要提供给Web使用，所以Android中一般使用WebView加载显示，其实本质上也就是用 WebView 加载本地 H5。<br>ECharts的图表样式主要由option控制，option是由js编写，如下面代码就是一个简单折线图的option。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">    xAxis: &#123;</span><br><span class="line">        type: &apos;category&apos;,</span><br><span class="line">        data: [&apos;Mon&apos;, &apos;Tue&apos;, &apos;Wed&apos;, &apos;Thu&apos;, &apos;Fri&apos;, &apos;Sat&apos;, &apos;Sun&apos;]</span><br><span class="line">    &#125;,</span><br><span class="line">    yAxis: &#123;</span><br><span class="line">        type: &apos;value&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    series: [&#123;</span><br><span class="line">        data: [820, 932, 901, 934, 1290, 1330, 1320],</span><br><span class="line">        type: &apos;line&apos;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在andorid中使用ECharts,一般来讲我们有两种实现方案</p><ul><li>Android获取数据并封装好option，然后传递给h5，h5再对数据进行解析，调用ECharts绘制。<br>这种方案的难点在于option的属性太多了，封装起来太麻烦。</li><li>h5处理所有操作，进行获取数据，并调用ECharts进行绘制。<br>这种方案需要对js比较熟悉。</li></ul><p>这里我们采用第一种方案，因为前人栽树后人乘凉，已经有大神帮我们做好最困难的数据封装工作：<a href="https://link.jianshu.com?t=https://github.com/abel533/ECharts" target="_blank" rel="noopener">EChart java 对象库</a></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h5 id="配置ECharts"><a href="#配置ECharts" class="headerlink" title="配置ECharts"></a>配置ECharts</h5><ul><li>下载Echarts。你可以根据你的需求在ECharts官网<a href="http://echarts.baidu.com/download.html" target="_blank" rel="noopener">下载</a>需要的ECharts组件。我这里选择的是完整版。</li><li>将下载好的<code>echarts.min.js</code>文件放入工程中<code>assets</code>目录下。如果没有<code>assets</code>目录，可以先在<code>mian</code>目录下，通过右击 new -&gt; Folder -&gt; Assets Folder 创建。<br><img src="/images/assets.png" alt="assets.png"></li><li>编写echarts.html文件，并将echarts.html放入assets目录。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html style=&quot;height: 100%&quot;&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;</span><br><span class="line">        &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body style=&quot;height: 100%; margin: 0&quot;&gt;</span><br><span class="line">        &lt;div id=&quot;container&quot; style=&quot;height: 100%&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;script type=&quot;text/javascript&quot; src=&quot;./echarts.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">        &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">            var dom =document.getElementById(&quot;container&quot;);</span><br><span class="line">            var myChart =echarts.init(dom);</span><br><span class="line">            var app =&#123;&#125;;</span><br><span class="line">            function loadEcharts(echartJson)&#123;</span><br><span class="line">                var option = JSON.parse(echartJson);</span><br><span class="line">                if (option &amp;&amp;typeof option ===&quot;object&quot;) &#123;</span><br><span class="line">                    myChart.setOption(option,true);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="依赖EChart-java-对象库"><a href="#依赖EChart-java-对象库" class="headerlink" title="依赖EChart java 对象库"></a>依赖EChart java 对象库</h5><blockquote><p>注意：因为该对象库依赖Gson，所以project同样需要添加Gson依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.github.abel533:ECharts:3.0.0.2&apos;</span><br><span class="line">    implementation &apos;com.google.code.gson:gson:2.8.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>因为Echarts需要在WebView中显示，所以我们直接自定义一个EchartView继承自WebView用来显示图表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class EchartView extends WebView &#123;</span><br><span class="line">    private static final String TAG = EchartView.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    public EchartView(Context context) &#123;</span><br><span class="line">        this(context, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public EchartView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        this(context, attrs, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public EchartView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init() &#123;</span><br><span class="line">        WebSettings webSettings = getSettings();</span><br><span class="line">        webSettings.setJavaScriptEnabled(true);</span><br><span class="line">        webSettings.setJavaScriptCanOpenWindowsAutomatically(true);</span><br><span class="line">        webSettings.setSupportZoom(false);</span><br><span class="line">        webSettings.setDisplayZoomControls(false);</span><br><span class="line">        loadUrl(&quot;file:///android_asset/echarts.html&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**刷新图表</span><br><span class="line">     * java调用js的loadEcharts方法刷新echart</span><br><span class="line">     * 不能在第一时间就用此方法来显示图表，因为第一时间html的标签还未加载完成，不能获取到标签值</span><br><span class="line">     * @param option</span><br><span class="line">     */</span><br><span class="line">    public void refreshEchartsWithOption(GsonOption option) &#123;</span><br><span class="line">        if (option == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String optionString = option.toString();</span><br><span class="line">        String call = &quot;javascript:loadEcharts(&apos;&quot; + optionString + &quot;&apos;)&quot;;</span><br><span class="line">        loadUrl(call);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定义一个工具类用来将数据封装为option，这里只封装了一个简单的折线图做例子。<br>更多图表的封装请参照<code>EChart java 对象库</code>和<a href="http://echarts.baidu.com/examples/index.html" target="_blank" rel="noopener">ECharts官方例子</a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class EchartOptionUtil &#123;</span><br><span class="line"></span><br><span class="line">    public static GsonOption getLineChartOptions(Object[] xAxis, Object[] yAxis) &#123;</span><br><span class="line">        GsonOption option = new GsonOption();</span><br><span class="line">        option.title(&quot;折线图&quot;);</span><br><span class="line">        option.legend(&quot;销量&quot;);</span><br><span class="line">        option.tooltip().trigger(Trigger.axis);</span><br><span class="line"></span><br><span class="line">        ValueAxis valueAxis = new ValueAxis();</span><br><span class="line">        option.yAxis(valueAxis);</span><br><span class="line"></span><br><span class="line">        CategoryAxis categorxAxis = new CategoryAxis();</span><br><span class="line">        categorxAxis.axisLine().onZero(false);</span><br><span class="line">        categorxAxis.boundaryGap(true);</span><br><span class="line">        categorxAxis.data(xAxis);</span><br><span class="line">        option.xAxis(categorxAxis);</span><br><span class="line"></span><br><span class="line">        Line line = new Line();</span><br><span class="line">        line.smooth(false).name(&quot;销量&quot;).data(yAxis).itemStyle().normal().lineStyle().shadowColor(&quot;rgba(0,0,0,0.4)&quot;);</span><br><span class="line">        option.series(line);</span><br><span class="line">        return option;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Acitvity中显示<br>activity_main.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    tools:context=&quot;com.example.ming.echartsforandroid.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;com.example.ming.echartsforandroid.EchartView</span><br><span class="line">        android:id=&quot;@+id/lineChart&quot;</span><br><span class="line">        android:layout_width=&quot;400dp&quot;</span><br><span class="line">        android:layout_height=&quot;400dp&quot;</span><br><span class="line">        android:layout_gravity=&quot;center&quot;&gt;</span><br><span class="line">    &lt;/com.example.ming.echartsforandroid.EchartView&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>MainActivity .java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    private EchartView lineChart;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        lineChart = findViewById(R.id.lineChart);</span><br><span class="line">        lineChart.setWebViewClient(new WebViewClient()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onPageFinished(WebView view, String url) &#123;</span><br><span class="line">                super.onPageFinished(view, url);</span><br><span class="line">                //最好在h5页面加载完毕后再加载数据，防止html的标签还未加载完成，不能正常显示</span><br><span class="line">                refreshLineChart();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void refreshLineChart()&#123;</span><br><span class="line">        Object[] x = new Object[]&#123;</span><br><span class="line">                &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;</span><br><span class="line">        &#125;;</span><br><span class="line">        Object[] y = new Object[]&#123;</span><br><span class="line">                820, 932, 901, 934, 1290, 1330, 1320</span><br><span class="line">        &#125;;</span><br><span class="line">        lineChart.refreshEchartsWithOption(EchartOptionUtil.getLineChartOptions(x, y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/Screenshot_2018-04-11-14-36-32-219_com.example.ming.echartsforandroid.png" alt="Screenshot_2018-04-11-14-36-32-219_com.example.ming.echartsforandroid.png"></p><p>#后记<br><a href="https://link.jianshu.com?t=https://github.com/abel533/ECharts" target="_blank" rel="noopener">EChart java 对象库</a>目前只封装了常用的十几种图表，所以如果需要用到更多的图表，建议直接下载EChart java 对象库代码，对其进行扩充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;支持原创，转载请注明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;做Android开发经常会需要画一些图表，自己
      
    
    </summary>
    
      <category term="Android" scheme="http://snsfrontend.crysnower.cn/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>AboutUs</title>
    <link href="http://snsfrontend.crysnower.cn/AboutUs.html"/>
    <id>http://snsfrontend.crysnower.cn/AboutUs.html</id>
    <published>2018-04-28T05:58:00.000Z</published>
    <updated>2018-05-21T03:36:37.106Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Suning-Sports-Front-End-Team"><a href="#Suning-Sports-Front-End-Team" class="headerlink" title="Suning Sports Front-End Team."></a>Suning Sports Front-End Team.</h3><p><img src="/images/snteam.jpeg" alt="苏宁体育"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Suning-Sports-Front-End-Team&quot;&gt;&lt;a href=&quot;#Suning-Sports-Front-End-Team&quot; class=&quot;headerlink&quot; title=&quot;Suning Sports Front-End Team.&quot;&gt;&lt;/a&gt;S
      
    
    </summary>
    
      <category term="项目管理" scheme="http://snsfrontend.crysnower.cn/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>代码规范</title>
    <link href="http://snsfrontend.crysnower.cn/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83.html"/>
    <id>http://snsfrontend.crysnower.cn/代码规范.html</id>
    <published>2017-09-12T00:12:30.000Z</published>
    <updated>2018-05-21T06:30:02.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要有代码规范？"><a href="#为什么要有代码规范？" class="headerlink" title="为什么要有代码规范？"></a>为什么要有代码规范？</h1><p>对于团队，如果代码风格不统一，阅读或修改同事的代码会非常困难，造成潜在的风险。</p><p>对于个人，代码规范是对自身编码习惯的一种监督，如果没有这种监督，有时候因为偷懒，会写出难看的代码，时间长了自己都看不懂。这样对于代码的维护性是不利的。</p><h1 id="代码规范的内容？"><a href="#代码规范的内容？" class="headerlink" title="代码规范的内容？"></a>代码规范的内容？</h1><p>代码规范包含的范围十分广泛。从一个变量的命名到一个类的设计，我觉得都属于代码规范的范畴。从实践的角度，可以把代码规范分成两个部分：</p><p>第一部分是规则，即一定要这么做。这里面没有对错，但需要统一。包含变量的命名、函数的命名、模块的组织、代码块的组织、宏、枚举、常量的声明、函数的粒度。</p><p>第二部分是风格，即一种模式化的代码设计结构。我们实现某个功能时，往往不止一种实现方式。每一种实现方式没有绝对的高低之分，不同角度的解读，就会有不同的偏好。所以这个层面上的代码规范，只能求同存异。但是不管怎样，每个人必须要有一致性的风格。就像不同的小区可以有不同的风格，但同一个小区只能有一种设计风格。风格包含代码设计中的抽象概念，比如接口、继承等等。</p><h1 id="代码的规则"><a href="#代码的规则" class="headerlink" title="代码的规则"></a>代码的规则</h1><p>规则如同法律，尽管从心底里很多人不认可，但每个人都必须遵守。看起来大家都受了束缚，但是对整个社会以及每一个人都是利大于弊。</p><h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><p>变量命名历史上产生过很多方法，比较著名的有匈牙利命名法、驼峰命名法、下划线命名法。</p><ul><li>匈牙利命名法：szUserName</li><li>驼峰命名法：userName</li><li>下划线命名法：user_name</li></ul><p>用Objective-C开发，我们就参考苹果的官方命名方式即可，苹果采用的是驼峰命名法。</p><p>苹果的变量命名方式常常被其它语言的开发者所吐槽，因为它的名有时候是在太长了！！！下面是3个最长的Objective-C属性名：<br>automaticallyEnablesStillImageStabilizationWhenAvailable<br>availableMediaCharacteristicsWithMediaSelectionOptions<br>outputObscuredDueToInsufficientExternalProtection<br>变量声明最重要的是清晰其次才考虑长短，如果为了简短而含糊不清，是不可取的。</p><blockquote><p><a href="http://segmentfault.com/a/1190000000370048" target="_blank" rel="noopener">Objective-C项目的命名有多长</a></p></blockquote><p>拿现有代码举例</p><table><br><thead><br><tr><br>  <th align="left">变量含义</th><br>  <th align="left">Not Good</th><br>  <th align="left">Good</th><br></tr><br></thead><br><tbody><br><tr><br>  <td align="left">昵称输入框</td><br>  <td align="left">tfNickName</td><br>  <td align="left">nickNameTextField</td><br></tr><br><tr><br>  <td align="left">密码ImageView</td><br>  <td align="left">imvPass</td><br>  <td align="left">passwordImageView</td><br></tr><br><tr><br>  <td align="left">我的搜索条</td><br>  <td align="left">mysearchBar</td><br>  <td align="left">mySearchBar</td><br></tr><br></tbody><br></table><p><strong>类变量</strong><br>前面加下划线，和系统框架保持一致</p><pre><code>@interface UIViewController : UIResponder &amp;amp;lt;NSCoding, UIAppearanceContainer&amp;amp;gt; {    @package    UIView           *_view;    UITabBarItem     *_tabBarItem;    UINavigationItem *_navigationItem;    NSArray          *_toolbarItems;    NSString         *_title;    NSString         *_nibName;    NSBundle         *_nibBundle;    ...... `&lt;/pre&gt;现有的例子&lt;pre&gt;`@interface CouponListTableViewCell : UITableViewCell{    UIImageView *imageIcon;    UIImageView *imageCollect;    UILabel *labelName;    UILabel *labelPriceSale;    UILabel *labelPriceOrigin;    UILabel *labelSaleNumber;    UIImageView *imageArrow;}`&lt;/pre&gt;**类变量与属性**属性是Objective-C的一种高级语法，属性可以完全替换类变量，并且提供更强大的访问控制（strong、weak、nonatomic、readonly...）,而且属性也只需要用一行就能搞定，所以为什么还要用类变量呢？属性声明后不用写@synthesize，且会自动生成类变量。[资料&gt;](http://stackoverflow.com/questions/12119284/xcode-4-automatically-generates-ivars-when-using-property-where-can-i-find-the)**例外**一些局部变量允许用最简单的方式命名：i、j、temp一些常用的缩写可以不用驼峰：RMB，OBD## 函数命名Objective-C中的函数不同于其他语言，函数名是按参数隔开的。初看起来是有点怪，但是习惯了就会发现这样和命名方式可读性极好，就像一句话一样。所以当你的函数名不能流利的读出来的话，那么它的命名肯定就有问题。还是先举系统的例子&lt;pre&gt;`- (void)willAnimateFirstHalfOfRotationToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration`&lt;/pre&gt;这里面值得注意的几点：- 最左边的（+、-）和返回类型的左括号之间有一个空格，返回类型的右括号与第一个参数之间没有空格；- 函数名中每一段描述都以小写字母开头，描述的写法要考虑清晰明确，参考变量命名；- 如果函数名过长，应该换行，按冒号对齐；- 从描述中可以看出对应参数的意义。再看看我们自己的命名&lt;pre&gt;`1、最后一个参数描述Selector首字母大写了+(UIButton *)createButton:(MUButtonItemAttribute *)attr target:(id)target Selector:(SEL)sel;2、有一些多余的空格+ (AppDelegate *) appDelegate;- (void)hideTabbar :(BOOL)status;3、加减号和括号之间要有空格-(void)pushEvent:(NSDictionary*)dictionary target:(id)target;4、参数名和参数要对应，含义清晰- (void)setNavBackButton:(NSString *)string;- (id)init:(NSString*)nickName phoneNumber:(NSString *)phoneNumber;- (void)setTextFieldBackGroud:(CGRect)rect;- (id)init:(NSInteger)flag;- (void)requestHealthRecord:(NSString *)typeStr;5、函数名过长要换行- (id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier containingTableView:(UITableView *)containingTableView leftUtilityButtons:(NSArray *)leftUtilityButtons rightUtilityButtons:(NSArray *)rightUtilityButtons;6、命名风格混乱+ (NSInteger) GetServerBack:(NSString *)serverName                 path_Param:(NSMutableDictionary*)path_Param                query_Param:(NSMutableDictionary*)query_Param                 body_Param:(NSMutableDictionary*)body_Param                     method:(NSInteger)method                returnValue:(NSMutableDictionary*)returnValue;7、参数之间用and、with，多此一举- (id)initWithFrame:(CGRect)frame andImageView:(UIImageView*)imageView withImageFrame:(CGRect)imageInitFrame withImageUrl:(NSURL*)imageUrl;`&lt;/pre&gt;**命名很重要！！！**良好的命名是写出高质量代码的前提，命名的时候除了符合以上的规范，还需要找到合适的单词来表达含义，不要为了一时之快用拼音，也千万不要出现数字。## 代码模块组织这个代码模块的组织是指文件级别的，即我们应该如何划分包。现有的包结构是有些问题的，导致我们找某个功能的实现文件比较麻烦。参考[别人的经验](http://www.cocoachina.com/industry/20140225/7879.html)，个人觉得这样的划分还是不错的。**文件的命名**我们自己创建的文件，应该有统一的前缀。比如HJMainViewController，这也符合系统的命名规范。Objective-C没有namespace，所以这样做的好处是当你引用了第三方的代码时，防止重名。而且当我们自己的代码越来越大时，内部也会出现冲突。**一个文件一个类**好处：- 减少单个文件的长度- 定位文件更方便- 便于重用## 代码块的组织作为一个程序员，大部分时间实在看代码而不是在写。所以代码的可读性严重影响到我们的工作效率。当你看到超过1000行的实现文件时，你还有看下去的欲望吗？所以千万不要写出超过1000行的代码，有的话也得[重构掉](http://www.objc.io/issue-1/)。当代码控制到1000行以内后，只是具备了可读的基本条件。我们的屏幕一般只能一次显示50行代码，从头看到尾就是20屏，常常会看了后面忘了前面。所以我们要把一个文件里面的所有函数有秩序的组织起来，让人不用重头看到尾，就能很快定位到想看的地方。这里提供一个小办法：用#pragma mark宏根据功能区分开:&lt;pre&gt;`#pragma mark - Life Circle#pragma mark - Public Interface#pragma mark - UI Actions#pragma mark - Business Logic#pragma mark - UITableViewDataSource#pragma mark - UITableViewDelegate#pragma mark - UIScrollViewDelegate#pragma mark - Notification Handle#pragma mark - Private Method`&lt;/pre&gt;## 宏、枚举、常量的声明宏的命名方式参考变量的命名方式，大写，用下划线分开&lt;pre&gt;`TARGET_OS_IPHONE`&lt;/pre&gt;枚举也有很多写法，这里推荐系统的方式&lt;pre&gt;`typedef NS_ENUM(NSInteger, NSTextAlignment) {    NSTextAlignmentLeft      = 0,    // Visually left aligned    NSTextAlignmentRight     = 1,    // Visually right aligned    NSTextAlignmentCenter    = 2,    // Visually centered    NSTextAlignmentJustified = 3,    // Fully-justified. The last line in a paragraph is natural-aligned.    NSTextAlignmentNatural   = 4,    // Indicates the default alignment for script} `&lt;/pre&gt;常量以k开头，系统命名风格&lt;pre&gt;`extern NSString *const kAPNetworkDidSetupNotification;     // 建立连接extern NSString *const kAPNetworkDidCloseNotification;     // 关闭连接extern NSString *const kAPNetworkDidRegisterNotification;  // 注册成功extern NSString *const kAPNetworkDidLoginNotification;     // 登录成功`&lt;/pre&gt;如果是数值常量，用宏的话，也可以用k开头&lt;pre&gt;`#define kDistancePoint  10.0f   // 圆点、标志和正文的间距`&lt;/pre&gt;## 函数的粒度知道我们现在最长的函数有多少行吗？655行。&lt;pre&gt;`- (void)getShopDetail`&lt;/pre&gt;一个函数最好不超过一屏（50行），千万不能超过两屏（100行）。因为从设计的角度来说，一个函数只需要干一件事，所以50行一般是够的，超长的函数往往干了很多事情，或者干了一件很大的事（拆成多件小事，交给子函数去干）。## 其它</code></pre><ul><li><strong>Log</strong>：不要使用NSLog，提交了会因想到别人，而且最后打包删起来麻烦。需要找一个Log工具，MyNSLog功能不够。</li><li><p><strong>代码中尽量不要出现数字</strong>：据上下文推测出来的，还是计算的出为好（现在界面里面很多地方确实要写死数字，适配iPhone6会很困难）</p><pre>`_contentBkg = [[UIView alloc] initWithFrame:CGRectMake(0, 1 / [UIScreen mainScreen].scale, 320, 68 - 1)];`</pre></li><li><p><strong>避免复杂的表达式</strong>：</p><pre>`    if (tfPassword.text!=nil &amp;amp;&amp;amp;        ![tfPassword.text isEqualToString:@&amp;quot;&amp;quot;] &amp;amp;&amp;amp;        tfRequestNumber.text!=nil &amp;amp;&amp;amp;        ![tfRequestNumber.text isEqualToString:@&amp;quot;&amp;quot;]        )    {    }`</pre></li><li><p><strong>一个变量不在多个函数中出现，不要作为类变量：</strong></p><pre>`MBProgressHUD* hudProgress;int result;`</pre></li><li><p><strong>每个类的.h开头的地方要有注释，说明这个类是干嘛的</strong></p><pre>`/** * SDImageCache maintains a memory cache and an optional disk cache. Disk cache write operations are performed * asynchronous so it doesn’t add unnecessary latency to the UI. */@interface SDImageCache : NSObject`</pre></li><li><p><strong>if后面的语句哪怕只有一行，都加括号</strong></p><pre>`if ([key rangeOfString:@&amp;quot;热&amp;quot;].location != NSNotFound) {            titleLabel.text = @&amp;quot;热门城市&amp;quot;;     }     else            titleLabel.text = key;`</pre><h1 id="代码的风格"><a href="#代码的风格" class="headerlink" title="代码的风格"></a>代码的风格</h1><p>风格如同习俗，不同地区有不同的习俗。你觉得入乡随俗好，就入乡随俗，这样避免了一些无谓的麻烦；但是你若坚持原有的习俗，社会也是能接受的，毕竟这些东西都是发展变化的，没有固定的模式，只有更好的模式。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>这里的接口指的是一个类公开的一组方法，良好设计的类是高内聚低耦合的，所以接口必须是简洁的。</p><p><pre>`@interface PaySucceedViewController : LCBaseViewController</pre></p><p>@property (nonatomic,retain) NSString *isSuccess;</p><p>@property (nonatomic,retain) NSString *shopName;</p><p>@property (nonatomic,retain) NSString *detailinfo;</p><p>@property (nonatomic,retain) NSString *amount;</p><p>@property (nonatomic,retain) NSString <em>omsOrderId;<br>/</em>!</p><ul><li>支付订单类型<br>*</li><li>@since<br>*/<br>@property (nonatomic) ORDER_CATEGORY mCategory;</li></ul><p>@end</p></li></ul><p>上面的例子是一个ViewController，但是它暴露了太多属性，属性很零碎，传值的时候要一个一个传。其实这里属性应该属于一个叫订单Model的对象，把这些属性封装在OrderModel中，复用性和可维护性都会好很多。（但是现在代码整体结构没有Model层，这里需要很大的重构）</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承不是为了少写代码，它的目的是抽象，顺便少写了代码。<br>举NavigationBar的例子，用宏可以实现，用基类也可以实现，但基类抽象出了一个共有的接口，以后发生共性的变化够可以通过修改基类来实现，你可以在基类里加一组方法，而宏做不到。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>代码规范的路还长着，先走出第一步吧！</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html" target="_blank" rel="noopener">Apple代码规范</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么要有代码规范？&quot;&gt;&lt;a href=&quot;#为什么要有代码规范？&quot; class=&quot;headerlink&quot; title=&quot;为什么要有代码规范？&quot;&gt;&lt;/a&gt;为什么要有代码规范？&lt;/h1&gt;&lt;p&gt;对于团队，如果代码风格不统一，阅读或修改同事的代码会非常困难，造成潜在的风险
      
    
    </summary>
    
      <category term="iOS" scheme="http://snsfrontend.crysnower.cn/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>关于文档类工作输出要求</title>
    <link href="http://snsfrontend.crysnower.cn/%E5%85%B3%E4%BA%8E%E6%96%87%E6%A1%A3%E7%B1%BB%E5%B7%A5%E4%BD%9C%E8%BE%93%E5%87%BA%E8%A6%81%E6%B1%82.html"/>
    <id>http://snsfrontend.crysnower.cn/关于文档类工作输出要求.html</id>
    <published>2017-09-12T00:12:30.000Z</published>
    <updated>2018-05-21T06:34:40.891Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Markdown.png" alt="markdown"></p><h2 id="模板说明"><a href="#模板说明" class="headerlink" title="模板说明"></a>模板说明</h2><ul><li>title 文档的标题</li><li>date 文档编写或修改的时间</li><li>categories 文档的类别，多个以半角逗号和方括号构成</li><li>tags 文档的tag，多个以半角逗号和方括号构成</li><li>分隔符—这一行保留</li><li><code>&lt;!--more--&gt;</code>和分隔符<code>---</code>之间的内容为文档摘要</li><li>其中图片必须使用本地相对路径<code>![imag](/images/xxx.png)</code></li><li>文档提交地址<a href="http://172.16.128.161/ios/technology-blog.git" target="_blank" rel="noopener">http://172.16.128.161/ios/technology-blog.git</a></li><li>文档地址 ./source/_posts/*.md</li><li>图片地址 ./source/images/*.png</li><li>xxx 正文<a id="more"></a>#关于文档类工作输出要求</li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><pre><code>title: iOS代码规范date: 2014-11-07 13:38:14categories: [iOS]tags: [效率]---# 代码规范的内容？代码规范包含的范围十分广泛。从一个变量的命名到一个类的设计，我觉得都属于代码规范的范畴。从实践的角度，可以把代码规范分成两个部分：第一部分是规则，即一定要这么做。这里面没有对错，但需要统一。包含变量的命名、函数的命名、模块的组织、代码块的组织、宏、枚举、常量的声明、函数的粒度。第二部分是风格，即一种模式化的代码设计结构。我们实现某个功能时，往往不止一种实现方式。每一种实现    方式没有绝对的高低之分，不同角度的解读，就会有不同的偏好。所以这个层面上的代码规范，只能求同存异。但是不管怎样，每个人必须要有一致性的风格。就像不同的小区可以有不同的风格，但同一个小区只能有一种设计风格。风格包含代码设计中的抽象概念，比如接口、继承等等。&lt;!--more--&gt;xxxxxx</code></pre><h2 id="模板说明-1"><a href="#模板说明-1" class="headerlink" title="模板说明"></a>模板说明</h2><ul><li>title 文档的标题</li><li>data 文档编写或修改的时间</li><li>categories 文档的类别，多个以半角逗号和方括号构成</li><li>tags 文档的tag，多个以半角逗号和方括号构成</li><li>分隔符—这一行保留</li><li><code>&lt;!--more--&gt;</code>和分隔符<code>---</code>之间的内容为文档摘要</li><li>其中图片必须使用本地相对路径<code>![imag](/images/xxx.png)</code></li><li>文档提交地址<a href="http://172.16.128.161/ios/technology-blog.git" target="_blank" rel="noopener">http://172.16.128.161/ios/technology-blog.git</a></li><li>文档地址 ./source/_posts/*.md</li><li>图片地址 ./source/images/*.png</li><li>xxx 正文</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/Markdown.png&quot; alt=&quot;markdown&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;模板说明&quot;&gt;&lt;a href=&quot;#模板说明&quot; class=&quot;headerlink&quot; title=&quot;模板说明&quot;&gt;&lt;/a&gt;模板说明&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;title 文档的标题&lt;/li&gt;
&lt;li&gt;date 文档编写或修改的时间&lt;/li&gt;
&lt;li&gt;categories 文档的类别，多个以半角逗号和方括号构成&lt;/li&gt;
&lt;li&gt;tags 文档的tag，多个以半角逗号和方括号构成&lt;/li&gt;
&lt;li&gt;分隔符—这一行保留&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;!--more--&amp;gt;&lt;/code&gt;和分隔符&lt;code&gt;---&lt;/code&gt;之间的内容为文档摘要&lt;/li&gt;
&lt;li&gt;其中图片必须使用本地相对路径&lt;code&gt;![imag](/images/xxx.png)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;文档提交地址&lt;a href=&quot;http://172.16.128.161/ios/technology-blog.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://172.16.128.161/ios/technology-blog.git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;文档地址 ./source/_posts/*.md&lt;/li&gt;
&lt;li&gt;图片地址 ./source/images/*.png&lt;/li&gt;
&lt;li&gt;xxx 正文
    
    </summary>
    
      <category term="iOS" scheme="http://snsfrontend.crysnower.cn/categories/iOS/"/>
    
    
      <category term="效率" scheme="http://snsfrontend.crysnower.cn/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>POP框架初探</title>
    <link href="http://snsfrontend.crysnower.cn/POP%E6%A1%86%E6%9E%B6%E5%88%9D%E6%8E%A2.html"/>
    <id>http://snsfrontend.crysnower.cn/POP框架初探.html</id>
    <published>2017-09-12T00:12:30.000Z</published>
    <updated>2018-05-21T06:23:24.672Z</updated>
    
    <content type="html"><![CDATA[<p>合适的动画效果是提高用户体验最直观的方式，我们项目中的动画应用也不少，主要是使用的UIKit的动画扩展，还有少量用CoreAnimation实现。现在Facebook开源了POP，我们又多了一种强大好用的选择。与CoreAnimation相比，api用法相似，POP提供了更多方便生动的动画效果，主要是弹簧（SpringAnimation）和衰减（DecayAnimation）效果。</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>POP的使用跟CoreAnimation比较相似，基本的步骤如下：</p><ul><li>选择一种动画效果<br>1.POPBasicAnimation 基本的动画效果，我们常用的EaseInOut、Linenear的动画效果都可以用这种方式实现</li></ul><p>2.POPSpringAnimation 弹簧效果，如下图</p><p><img src="/images/pop.gif" alt="pop.gif"></p><pre><code>POPSpringAnimation *springAnimation = [POPSpringAnimation animation];springAnimation.springBounciness=14;    // 弹簧弹力 取值范围为[0, 20]，默认值为4springAnimation.springSpeed=3;     // 弹簧速度，速度越快，动画时间越短 [0, 20]，默认为12，和springBounciness一起决定着弹簧动画的效果<a id="more"></a>合适的动画效果是提高用户体验最直观的方式，我们项目中的动画应用也不少，主要是使用的UIKit的动画扩展，还有少量用CoreAnimation实现。现在Facebook开源了POP，我们又多了一种强大好用的选择。与CoreAnimation相比，api用法相似，POP提供了更多方便生动的动画效果，主要是弹簧（SpringAnimation）和衰减（DecayAnimation）效果。# 使用方法POP的使用跟CoreAnimation比较相似，基本的步骤如下：- 选择一种动画效果1.POPBasicAnimation 基本的动画效果，我们常用的EaseInOut、Linenear的动画效果都可以用这种方式实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POPBasicAnimation *basicAnimation = [POPBasicAnimation animation];</span><br><span class="line">basicAnimation.timingFunction=[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];</span><br><span class="line">// kCAMediaTimingFunctionLinear  kCAMediaTimingFunctionEaseIn  kCAMediaTimingFunctionEaseOut  kCAMediaTimingFunctionEaseInEaseOut</span><br></pre></td></tr></table></figure>2.POPSpringAnimation 弹簧效果，如下图![pop.gif](/images/pop.gif)<pre><code>POPSpringAnimation *springAnimation = [POPSpringAnimation animation];springAnimation.springBounciness=14;    // 弹簧弹力 取值范围为[0, 20]，默认值为4springAnimation.springSpeed=3;     // 弹簧速度，速度越快，动画时间越短 [0, 20]，默认为12，和springBounciness一起决定着弹簧动画的效果// 还有：dynamicsTension 弹簧的张力 dynamicsFriction 弹簧摩擦 dynamicsMass 质量 。张力，摩擦，质量这三者可以从更细的粒度上替代springBounciness和springSpeed控制弹簧动画的效果</code></pre>3.POPDecayAnimation 衰减效果，参考UIScrollView滑动松手后的减速<pre><code>POPDecayAnimation *decayAnimation=[POPDecayAnimation animation];decayAnimation.velocity=@(233); //值的变化速率</code></pre><ul><li>选择生成动画的Property<br>View Properties，包含以下定义<br>kPOPViewAlpha  kPOPViewBackgroundColor kPOPViewBounds kPOPViewCenter kPOPViewFrame kPOPViewScaleXY  kPOPViewSize</li></ul><p>Layer Properties<br>kPOPLayerBackgroundColor kPOPLayerBounds kPOPLayerScaleXY kPOPLayerSize kPOPLayerOpacity kPOPLayerPosition kPOPLayerPositionX kPOPLayerPositionY  kPOPLayerRotation kPOPLayerBackgroundColor</p><ul><li><p>设置对应的.toValue<br>例如</p><pre><code>// 设置alphaPOPBasicAnimation *basicAnimation = [POPBasicAnimation animation];basicAnimation.property = [POPAnimatableProperty propertyWithName:kPOPViewAlpha];basicAnimation.toValue= @(0);// 设置BackgroundColorPOPSpringAnimation *basicAnimation = [POPSpringAnimation animation];basicAnimation.property = [POPAnimatableProperty propertyWithName: kPOPLayerBackgroundColor];basicAnimation.toValue= [UIColor redColor];</code></pre></li><li><p>为动画设置name和delegate<br><pre><code><br>basicAnimation.name=@”POPAnimation”;<br>basicAnimation.delegate=self;<br></code></pre><br>delegate方法如下</p></li></ul><pre><code>- (void)pop_animationDidStart:(POPAnimation *)anim;- (void)pop_animationDidStop:(POPAnimation *)anim finished:(BOOL)finished;- (void)pop_animationDidReachToValue:(POPAnimation *)anim;</code></pre>- 将animation添加到对象上<pre><code>[self.tableView pop_addAnimation:basicAnimation forKey:@"POPAnimation"];</code></pre><h1 id="完整例子"><a href="#完整例子" class="headerlink" title="完整例子"></a>完整例子</h1><pre><code>POPSpringAnimation *basicAnimation = [POPSpringAnimation animation];basicAnimation.property = [POPAnimatableProperty propertyWithName:kPOPViewFrame];basicAnimation.toValue=[NSValue valueWithCGRect:CGRectMake(0, 0, 90, 190)];basicAnimation.name=@"SomeAnimationNameYouChoose";basicAnimation.delegate=self;[self.tableView pop_addAnimation:basicAnimation forKey:@"POPAnimation"];</code></pre></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;合适的动画效果是提高用户体验最直观的方式，我们项目中的动画应用也不少，主要是使用的UIKit的动画扩展，还有少量用CoreAnimation实现。现在Facebook开源了POP，我们又多了一种强大好用的选择。与CoreAnimation相比，api用法相似，POP提供了更多方便生动的动画效果，主要是弹簧（SpringAnimation）和衰减（DecayAnimation）效果。&lt;/p&gt;
&lt;h1 id=&quot;使用方法&quot;&gt;&lt;a href=&quot;#使用方法&quot; class=&quot;headerlink&quot; title=&quot;使用方法&quot;&gt;&lt;/a&gt;使用方法&lt;/h1&gt;&lt;p&gt;POP的使用跟CoreAnimation比较相似，基本的步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择一种动画效果&lt;br&gt;1.POPBasicAnimation 基本的动画效果，我们常用的EaseInOut、Linenear的动画效果都可以用这种方式实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.POPSpringAnimation 弹簧效果，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/pop.gif&quot; alt=&quot;pop.gif&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
POPSpringAnimation *springAnimation = [POPSpringAnimation animation];
springAnimation.springBounciness=14;    // 弹簧弹力 取值范围为[0, 20]，默认值为4
springAnimation.springSpeed=3;     // 弹簧速度，速度越快，动画时间越短 [0, 20]，默认为12，和springBounciness一起决定着弹簧动画的效果
    
    </summary>
    
      <category term="iOS" scheme="http://snsfrontend.crysnower.cn/categories/iOS/"/>
    
    
      <category term="POP" scheme="http://snsfrontend.crysnower.cn/tags/POP/"/>
    
      <category term="动画" scheme="http://snsfrontend.crysnower.cn/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>sourceTree使用注意事项</title>
    <link href="http://snsfrontend.crysnower.cn/sourceTree%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.html"/>
    <id>http://snsfrontend.crysnower.cn/sourceTree使用注意事项.html</id>
    <published>2017-09-12T00:12:30.000Z</published>
    <updated>2018-05-21T06:24:37.598Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/52a9bb493dfae92bab000005.jpg" alt="sourceTree"></p><h1 id="sourceTree使用注意事项"><a href="#sourceTree使用注意事项" class="headerlink" title="sourceTree使用注意事项"></a>sourceTree使用注意事项</h1><ul><li>更正上次文档《关于文档类工作输出要求》的错误，其中<code>其中图片必须使用本地相对路径![imag](../images/xxx.png)</code>应该为<code>其中图片必须使用本地相对路径![imag](/images/xxx.png)</code></li><li>点击list条目进入sourceTree工程页面<br><img src="/images/gitlist.png" alt="image"><br><br></li><li>点击顶部菜单栏的“抓取-fetch”，然后勾选<code>删除在所有远端都已经不存在的跟踪（tracking）分支</code><br><img src="/images/gitmenu.png" alt="image"><br><br></li></ul><p>这样就可以了同步本地的分支（服务器上已被删除而本地却有）了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/52a9bb493dfae92bab000005.jpg&quot; alt=&quot;sourceTree&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;sourceTree使用注意事项&quot;&gt;&lt;a href=&quot;#sourceTree使用注意事项&quot; class=&quot;header
      
    
    </summary>
    
      <category term="项目管理" scheme="http://snsfrontend.crysnower.cn/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="项目管理" scheme="http://snsfrontend.crysnower.cn/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>一处重复代码的改进</title>
    <link href="http://snsfrontend.crysnower.cn/%E4%B8%80%E5%A4%84%E9%87%8D%E5%A4%8D%E4%BB%A3%E7%A0%81%E7%9A%84%E6%94%B9%E8%BF%9B.html"/>
    <id>http://snsfrontend.crysnower.cn/一处重复代码的改进.html</id>
    <published>2015-02-11T09:23:14.000Z</published>
    <updated>2018-05-21T06:28:23.072Z</updated>
    
    <content type="html"><![CDATA[<p>在APP中列表是一种比较常见的数据展示方式，当有数据时，就显示数据；如果没有数据，一般不会显示一个空白页面，而是在空白页面上加一些提示信息，比如像下面这样<br><a id="more"></a></p><p><img src="http://upload-images.jianshu.io/upload_images/16632-3c612061647ab7d5.png" alt="no_message.png"></p><p>不同的APP会有不同的设计，但不管是什么样的设计，它在整个APP内部应该是一致的，要变也只是文字或图片稍有不同。</p><p>##现状<br>因为我们目前的项目还算比较庞大，所以这种列表无数据的情况出现了20多次，所以类似下面的代码出现了就有20多次。为什么说类似，因为是由不同的人写的，逻辑也是差不多，但真的各不相同，有的封装成一个方法，比如：setNoMessageView，有的直接写在viewDidLoad里面……<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)setNoMessageView</span><br><span class="line">&#123;</span><br><span class="line">    self.noInfoView = [[UIView alloc] initWithFrame:CGRectMake(0, 45, SCREEN_WIDTH, SCREEN_HEIGHT)];</span><br><span class="line">    self.noInfoView.backgroundColor = [UIColor clearColor];</span><br><span class="line">    [self.view addSubview:self.noInfoView];</span><br><span class="line">    </span><br><span class="line">    UIImageView *carImageView = [[UIImageView alloc] initWithFrame:CGRectMake((SCREEN_WIDTH-120)/2, 60, 120, 86)];</span><br><span class="line">    [carImageView setImage:[UIImage imageNamed:@&quot;no_message.png&quot;]];</span><br><span class="line">    [self.noInfoView addSubview:carImageView];</span><br><span class="line">    </span><br><span class="line">    UILabel *noInfoLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 160, SCREEN_WIDTH, 20)];</span><br><span class="line">    noInfoLabel.textAlignment = NSTextAlignmentCenter;</span><br><span class="line">    noInfoLabel.textColor = LCRGBColor(211, 211, 211);</span><br><span class="line">    noInfoLabel.text = NSLocalizedString(@&quot;Dear, no information&quot;, nil);</span><br><span class="line">    noInfoLabel.backgroundColor = [UIColor clearColor];</span><br><span class="line">    noInfoLabel.font = [LCFont systemFontOfSize:20];</span><br><span class="line">    [self.noInfoView addSubview:noInfoLabel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先不考虑重复的问题，只是孤立的看上述代码，它也有一些问题：</p><ul><li>self.noInfoView的frame应该视根据上下文获得的，而不是和屏幕大小绑定，而且yOffset是45也是不对的。</li><li>carImageView的frame是固定大小的，而图片有可能变。</li></ul><h2 id="第一个解决办法"><a href="#第一个解决办法" class="headerlink" title="第一个解决办法"></a>第一个解决办法</h2><p>因为创建noInfoView的代码基本差不多，我们可以封装出一个Util方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (UIView*)createNoMessageViewWithFrame:(CGRect)frame image:(UIImage*)image text:(NSString*)text</span><br><span class="line">&#123;</span><br><span class="line">    UIView* noMessageView = [[UIView alloc] initWithFrame:frame];</span><br><span class="line">    noMessageView.backgroundColor = [UIColor clearColor];</span><br><span class="line">    </span><br><span class="line">    UIImageView *carImageView = [[UIImageView alloc] initWithFrame:CGRectMake((frame.size.width-image.size.width)/2, 60, image.size.width, image.size.height)];</span><br><span class="line">    [carImageView setImage:image];</span><br><span class="line">    [noMessageView addSubview:carImageView];</span><br><span class="line">    </span><br><span class="line">    UILabel *noInfoLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 160, frame.size.width, 20)];</span><br><span class="line">    noInfoLabel.textAlignment = NSTextAlignmentCenter;</span><br><span class="line">    noInfoLabel.textColor = LCRGBColor(211, 211, 211);</span><br><span class="line">    noInfoLabel.text = text;</span><br><span class="line">    noInfoLabel.backgroundColor = [UIColor clearColor];</span><br><span class="line">    noInfoLabel.font = [LCFont systemFontOfSize:20];</span><br><span class="line">    [noMessageView addSubview:noInfoLabel];</span><br><span class="line">    </span><br><span class="line">    return noMessageView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)setNoMessageView</span><br><span class="line">&#123;</span><br><span class="line">    CGRect rect = self.shopListView.frame;</span><br><span class="line">    UIImage* image = [UIImage imageNamed:@&quot;no_message.png&quot;];</span><br><span class="line">    NSString* text = NSLocalizedString(@&quot;Dear, no information&quot;, nil);</span><br><span class="line">    self.noInfoView = [HJUIUtil createNoMessageViewWithFrame:rect image:image text:text];</span><br><span class="line">    [self.view addSubview:self.noInfoView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样改看起来好多了，把共性封装，把差异作为接口留出。然后其他地方原本要写20行代码，现在只要写5行，而且多个地方调用的代码不会有太大的出入，便于阅读和理解。</p><h2 id="第二个解决办法"><a href="#第二个解决办法" class="headerlink" title="第二个解决办法"></a>第二个解决办法</h2><p>上面的办法已经不错了，不过除了写5行代码之外，还给ViewController增加了一个属性：noInfoView。现在仔细想一下noInfoView出现的原因，是因为TableView没有内容显示的时候，noInfoView才显示出来，否则就隐藏。可见，这个noInfoView和TableView是紧密联系的，我们可以从UITableView的状态得出noInfoView的状态。那为什么不把它绑定到UITableView上呢？好，那就给UITableView增加一个属性，叫做emptyView。</p><p>给一个系统的类增加属性不是那么的简单，但是只要看过SVPullToRefresh的代码，就知道怎么做了。<br>首先，给UITableView增加一个Category。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface UITableView(EmptyView)</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong, readonly) UIView *emptyView;</span><br><span class="line"></span><br><span class="line">-(void)addEmptyViewWithImageName:(NSString*)imageName title:(NSString*)title;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">static char UITableViewEmptyView;</span><br><span class="line"></span><br><span class="line">@implementation UITableView(EmptyView)</span><br><span class="line"></span><br><span class="line">@dynamic emptyView;</span><br><span class="line"></span><br><span class="line">- (UIView *)emptyView</span><br><span class="line">&#123;</span><br><span class="line">    return objc_getAssociatedObject(self, &amp;UITableViewEmptyView);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setEmptyView:(UIView *)emptyView</span><br><span class="line">&#123;</span><br><span class="line">    [self willChangeValueForKey:@&quot;HJEmptyView&quot;];</span><br><span class="line">    objc_setAssociatedObject(self, &amp;UITableViewEmptyView,</span><br><span class="line">                             emptyView,</span><br><span class="line">                             OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">    [self didChangeValueForKey:@&quot;HJEmptyView&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-(void)addEmptyViewWithImageName:(NSString*)imageName title:(NSString*)title</span><br><span class="line">&#123;</span><br><span class="line">    if (!self.emptyView)</span><br><span class="line">    &#123;</span><br><span class="line">        CGRect frame = CGRectMake(0, 0, self.frame.size.width, self.frame.size.height);</span><br><span class="line">        UIImage* image = [UIImage imageNamed:imageName];</span><br><span class="line">        NSString* text = title;</span><br><span class="line">        </span><br><span class="line">        UIView* noMessageView = [[UIView alloc] initWithFrame:frame];</span><br><span class="line">        noMessageView.backgroundColor = [UIColor clearColor];</span><br><span class="line">        </span><br><span class="line">        UIImageView *carImageView = [[UIImageView alloc] initWithFrame:CGRectMake((frame.size.width-image.size.width)/2, 60, image.size.width, image.size.height)];</span><br><span class="line">        [carImageView setImage:image];</span><br><span class="line">        [noMessageView addSubview:carImageView];</span><br><span class="line">        </span><br><span class="line">        UILabel *noInfoLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 160, frame.size.width, 20)];</span><br><span class="line">        noInfoLabel.textAlignment = NSTextAlignmentCenter;</span><br><span class="line">        noInfoLabel.textColor = LCRGBColor(211, 211, 211);</span><br><span class="line">        noInfoLabel.text = text;</span><br><span class="line">        noInfoLabel.backgroundColor = [UIColor clearColor];</span><br><span class="line">        noInfoLabel.font = [LCFont systemFontOfSize:20];</span><br><span class="line">        [noMessageView addSubview:noInfoLabel];</span><br><span class="line">        </span><br><span class="line">        [self addSubview:noMessageView];</span><br><span class="line">        </span><br><span class="line">        self.emptyView = noMessageView;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>然后外部调用就很简单了，没有额外的属性，而且一句话就搞定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.shopListView.shopListTableView addEmptyViewWithImageName:@&quot;no_message.png&quot; title:@&quot;Dear, no information&quot;];</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在APP中列表是一种比较常见的数据展示方式，当有数据时，就显示数据；如果没有数据，一般不会显示一个空白页面，而是在空白页面上加一些提示信息，比如像下面这样&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://snsfrontend.crysnower.cn/categories/iOS/"/>
    
    
      <category term="代码优化" scheme="http://snsfrontend.crysnower.cn/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>如何写一个控件</title>
    <link href="http://snsfrontend.crysnower.cn/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E6%8E%A7%E4%BB%B6.html"/>
    <id>http://snsfrontend.crysnower.cn/如何写一个控件.html</id>
    <published>2015-02-04T09:23:14.000Z</published>
    <updated>2018-05-21T06:31:08.854Z</updated>
    
    <content type="html"><![CDATA[<p>写控件，是做客户端开发的一项基本功。为什么这么说呢？<br><a id="more"></a></p><p>#前言</p><p>写控件，是做客户端开发的一项基本功。为什么这么说呢？首先，写一个控件并不需要大量的代码（绝大部分1000行代码就可以搞定）；其次，写控件并不难，只要给出视觉效果，不管新手还是老手，都能够最终搞定（无非是时间长短而已）；但我觉得最重要的是，写控件很能体现出抽象和面向对象的思想。高质量的控件，调用者只需要很少的代码，就能够嵌入到不同的使用场景；而实现质量堪忧的控件，调用端写一大堆代码不说，需求上稍有变化，可能就要推倒重来了。最近正好在实现一个控件，花了整整一个工作日，虽然这个控件还有很多问题，但回想起过程中的一些思路和方法，觉得有必要总结下。</p><p>#需求</p><p>这是一个筛选控件，常见得不能再常见了，几乎是个APP都有这样的控件。直接上图：</p><p><img src="http://upload-images.jianshu.io/upload_images/16632-fa252bea2ac2d284.png" alt="control_1.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/16632-62c5eb1c842c1bbe.png" alt="control_2.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/16632-9b4af2300eeccf34.png" alt="control_3.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/16632-0fbf7ea7afc6df54.png" alt="control_4.png"></p><p>简单解释一下：<br>1、控件有两种类型，一种是有图片的（control_1.png），一种是没图片的（control_3.png）。<br>2、控件被选中的时候下方动画展开菜单，菜单高度根据菜单项的数量决定，但高度有上限。<br>3、菜单项选择了之后会标题按钮会更新成选择的文字，同时菜单项收回。<br>4、菜单项弹出式遮罩整个屏幕，点击遮罩部分，同时菜单项收回。<br>5、菜单分隔项数量，标题和图片，以及菜单项按钮的文字都是可变的。</p><p>#目标</p><p>有了需求，就要开始写了。但写之前，先要定个目标。因为写控件这种东西，没有产品经理来验收，所以不定目标的话，很容易自我妥协。</p><p>对于控件，我的目标一贯就是：让调用者写最少的代码。</p><p>这样有两个好处：</p><ul><li>减轻调用者的工作负担</li><li>减少调用者写错代码的可能性</li></ul><p>那么问题就来了：我想让对方用一行代码就调起控件，可是可变得东西太多，比如到底有没有图片，有几个筛选项，按钮和菜单的文字又是什么？所以对于这个控件，一行代码有点太天真了，有一部分数据必须是由调用者提供的。究竟是什么数据呢？先看我的第一个观点：</p><p>###观点一：可变性与不变性</p><p>所谓控件，是对UI设计的某种抽象。对于产品经理来说，并没有控件的概念，他只是把需求画在纸上，告诉你交互的逻辑，然后叫你实现。然后程序员按照需求画出了界面，似乎没有用到什么控件。</p><p>可不幸的是，第二天，产品经理又要改了，比如说把文字变大点，然后加粗，或者加个动画什么的。于是，你又重新把代码改了一遍。</p><p>可是，第三天、第四天……你怒了！不过为了保住饭碗，只能忍气吞声。</p><p>真的只能忍气吞声吗？不！那样太消极了。你难道就没有想过，每次产品经理改来改去，总有一些东西是不会变的，而那些变来变去的东西往往也就那么几样！</p><p>当你想到这一点的时候，你已经不再是菜鸟了，因为你已经了解到软件设计最灵魂的两个字：抽象。</p><p>抽象就是把一堆各不相同的东西看成一个。比如世界上每个人都不一样，但他们都是人。把不同的UI设计进行抽象，就是控件。从系统层面上来讲，UIView、UIButton、UILabel等等，都是控件。它们都有其本质的特点以区别于其他控件，但他们又具有丰富的扩展性，能够产生千变万化的效果。但万变又不离其中，Label还是Label，Button还是Button。</p><p>好像扯远了，收回来。我们现在要把上图的UI效果做成控件，就要知道哪些东西是可变的，哪些东西是不变的。</p><p>不变的：</p><ul><li>初始状态肯定是并排几个按钮，点一下下面的菜单就会展开，再点一下有收回</li><li>选中的按钮会有特殊状态以区别于其他按钮。</li><li>展开的菜单上面都显示字符串</li><li>点击展开菜单中的某一项，就会出发某个事件，然后菜单收回。</li></ul><p>可变的：</p><ul><li>按钮数量、图片、文字</li><li>展开的菜单项数量，菜单项内容。</li><li>选中项的位置（要高亮的位置）</li></ul><p>如果真要严格的讲，可变的内容太多了。但你要知道，可变即意味着控件自身不可知，只能从外部获取，这样就加大了调用者的工作量。所以，在实际设计控件时，我们只需提取几个最有可能发生变化的因素，其它的就当它是固定的即可。比如在这个例子中，弹出菜单的每一项的具体高度，是不是统一的？我就把它当成全部都是一样的，而且都是40，因为这种变化确实不太可能发生。但是像按钮和菜单项的文字，那是绝对会变的（不然还怎么扩展）。</p><p>总结一下，就是把可变的因素中最有可能的几个因素罗列出来，传给控件，然后通过控件的内部各种固定逻辑将其展现出来。</p><p>###观点二：主动传参与被动传参的选择</p><p>先解释一下主动传参与被动传参的概念，因为这是我自己脑补的。<br>主动传参：就是通过参数、属性的形式把参数传给控件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.menuView = [[LCSegmentMenuView alloc] initWithFrame:rect</span><br><span class="line">                                               containerView:self.view</span><br><span class="line">                                                   itemCount:3</span><br><span class="line">                                                       style:LCSegmentMenuStyle_Text];</span><br><span class="line">self.menuView.delegate = self;</span><br></pre></td></tr></table></figure></p><p>上面是控件调用代码，Frame、containerView:self、itemCount、style、delegate，这些都属于主动传参。它的特点除了传递方式之外，时间上都是先于控件控件自身逻辑运行之前。</p><p>被动传参：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">- (NSString*)segmentMenuView:(LCSegmentMenuView*)segmentMenuView titleAtSection:(NSUInteger)section</span><br><span class="line">&#123;</span><br><span class="line">    return self.menuTitles[section];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIImage*)segmentMenuView:(LCSegmentMenuView*)segmentMenuView imageAtSection:(NSUInteger)section</span><br><span class="line">&#123;</span><br><span class="line">    return self.menuImages[section];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIImage*)segmentMenuView:(LCSegmentMenuView*)segmentMenuView selectedImageAtSection:(NSUInteger)section</span><br><span class="line">&#123;</span><br><span class="line">    return self.menuSelectedImages[section];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSArray*)titlesInSegmentMenuView:(LCSegmentMenuView*)segmentMenuView atSection:(NSUInteger)section</span><br><span class="line">&#123;</span><br><span class="line">    if (section == 0) &#123;</span><br><span class="line">        return @[NSLocalizedString(@&quot;Total&quot;, nil),@&quot;5km&quot;,@&quot;10km&quot;,@&quot;15km&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    else if(section == 1)&#123;</span><br><span class="line">        </span><br><span class="line">        NSString* stringA = NSLocalizedString(@&quot;Total&quot;, nil);</span><br><span class="line">        NSString* stringB = NSLocalizedString(@&quot;Wash car&quot;, nil);</span><br><span class="line">        NSString* stringC = NSLocalizedString(@&quot;repair and maintain&quot;, nil);</span><br><span class="line">        NSString* stringD = NSLocalizedString(@&quot;Cosmetology&quot;, nil);</span><br><span class="line">        return @[stringA,stringB,stringC,stringD];</span><br><span class="line">    &#125;</span><br><span class="line">    else if(section == 2)&#123;</span><br><span class="line">        </span><br><span class="line">        NSString* stringA = NSLocalizedString(@&quot;Distance from near to far&quot;, nil);</span><br><span class="line">        NSString* stringB = NSLocalizedString(@&quot;Praise from high to low&quot;, nil);</span><br><span class="line">        NSString* stringC = NSLocalizedString(@&quot;Sales from high to low&quot;, nil);</span><br><span class="line">        return @[stringA,stringB,stringC];</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSUInteger)currentIndexInSegmentMenuView:(LCSegmentMenuView*)segmentMenuView atSection:(NSUInteger)section</span><br><span class="line">&#123;</span><br><span class="line">    return [self.menuIndexs[section] integerValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)segmentMenuView:(LCSegmentMenuView*)segmentMenuView didSelectAtIndexPath:(NSIndexPath*)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    self.menuIndexs[indexPath.section] = @(indexPath.row);</span><br><span class="line">    NSArray* array = [self titlesInSegmentMenuView:segmentMenuView atSection:indexPath.section];</span><br><span class="line">    self.menuTitles[indexPath.section] = array[indexPath.row];</span><br><span class="line">    </span><br><span class="line">    [self.parentVC.shops removeAllObjects];</span><br><span class="line">    self.currentPage = 0;</span><br><span class="line">    [self getShopList:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面几个方法，一看就是代理方法，这些方法提供的数据，可不是控件创建之初就知道的，而是由于人为的交互，改变的控件的内部状态，进而产生UI上的变化。对于调用者而言，这些数据都是被动的有控件来索取，所以称为被动传参。</p><p>在系统控件中，像UILabel全是主动传参，因为它没有交互；像UITableView，就有很多被动传参。被动传参除了Delegate，还可以用Block，KVO实现，主动传参就直来直去，简单的多。</p><p>总结一下，不到万不得已，尽量使用主动传参。但主动传参局限性太大了，只能发生在事前，不能发生在事中。所以，交互稍微复杂一点的控件，就要使用被控传参。</p><h3 id="观点三：控件结构化"><a href="#观点三：控件结构化" class="headerlink" title="观点三：控件结构化"></a>观点三：控件结构化</h3><p>上面提到传参，我们就穿了一堆参数。但是参数太多好乱，怎么办？原因就是没有结构化。</p><p>我们设计完控件，控件它就是一个对象，比如：LCSegmentMenuView。这个对象对应了一堆参数，什么title、index、image，这些零散的东西为什么不可以结构化成一个对象呢？这样我们的控件每次取外部数据，只要从这个结构化对象里面取就可以了（只要为这个对象增加几个对外接口）。<br>这样做的好处是显而易见的，本来外部调用者要管理如下的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,strong) NSMutableArray* menuTitles;</span><br><span class="line">@property (nonatomic,strong) NSArray* menuImages;</span><br><span class="line">@property (nonatomic,strong) NSArray* menuSelectedImages;</span><br><span class="line">@property (nonatomic,strong) NSMutableArray* menuIndexs;</span><br></pre></td></tr></table></figure></p><p>把它们结构化成一个对象之后，只要管理一个变量即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,strong) LCMenu* menu;</span><br></pre></td></tr></table></figure></p><p>这样就能避免很多因为代码零散而造成的复杂性。这样一个对象从抽象的角度来讲也是应该存在的，它就是控件的灵魂，没有它，控件就是一堆代码；有了它，控件遍丰富多彩。</p><p>可惜目前我还没有封装这个对象，因为我觉得四个变量管理起来也不是很复杂，反正要比新写一个对象简单。但如果变成了8个变量，我想我一定会去封装这个对象的。</p><p>#总结</p><p>说了这么多，具体控件实现没有讲。因为这个实在没什么好讲的，就是组装系统控件而已。等这个控件完善了，直接贴代码好了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写控件，是做客户端开发的一项基本功。为什么这么说呢？&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://snsfrontend.crysnower.cn/categories/iOS/"/>
    
    
      <category term="控件" scheme="http://snsfrontend.crysnower.cn/tags/%E6%8E%A7%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>谈谈“互联网”</title>
    <link href="http://snsfrontend.crysnower.cn/%E8%B0%88%E8%B0%88%E2%80%9C%E4%BA%92%E8%81%94%E7%BD%91%E2%80%9D.html"/>
    <id>http://snsfrontend.crysnower.cn/谈谈“互联网”.html</id>
    <published>2015-02-02T09:23:14.000Z</published>
    <updated>2018-05-21T06:33:25.151Z</updated>
    
    <content type="html"><![CDATA[<p>#谈谈“互联网”<br>借这个机会，让我们来说说互联网。有同学把它叫做作业，有人称之为论文，于我我想应该是随谈，谈谈我的认识，谈谈我的理解。<br>关于互联网会有很多话题可以聊，咱们就从一小一大两个方面去探索。一小，就是单个互联网尤其是移动互联网产品的创造历程；一大，就是未来互联网的发展猜测，当然了，也是自己的一点愚见而已。<br>互联网所呈现在大众眼前的载体是什么呢？是产品。淘宝是个产品，苏宁易购也是个产品，QQ也是个产品。不同的是，产品又大有小，有强有弱。那这些所谓“产品”的造物主们是如何将这些产品创造出来的呢？这就是今天所要聊得第一点。<br>互联网产品的诞生，可能是一个念头一个想法，但大都都是由于对现实的不满而产生的。好比说，之前写信，觉得很麻烦写完还得寄，寄完还得等，于是后来有了电报，后来又有了电话，后来又有了IM，语音，视频聊天。所以，一个不满一个好的idea是互联网产品的一个开始，但是这远远不够，因为它只是一个idea而已，谁都会发牢骚，谁都会有想法。要想成为一个造物主，其具备的能力应该包括三个阶段。阶段一：将idea变成一个可以运作的项目；阶段二：将这个项目变成一个可以运营的产品；阶段三：将这个产品，变成利润。<br>而今天，我们只谈关于第一阶段的事情。生理学讲，一个想法只是一簇脑电波，一种思维方式也只不过是脑电波局动的一组规律样本。如果你是个有心人，捕获住了这一簇脑电波，并且用持久化的方式记录了下来，那么恭喜，你已经拥有了这个产品的蓝本，这种持久化，可能存在于iPhone中的备忘录中，也可能是笔尖草草的留书。<br>如果说“想法”是女娲手中的一滩泥的话，那么接下来的跨越就决定这摊泥是捏成人形的还是nothing。那，接下来究竟需要做什么？画出来。画出wireframe，异或称之为“草图”、“线框图”。其实他的作用是用来联系，联系想法和实际大量信息之间的映射；联系自我思维和他人认知的桥梁。并且可以验证伟大的想法究竟能不能由己之力落地生根。<br>Wireframe将想法呈现在纸面上这是一个跨越，之所以是跨越，因为这两个阶段之间其实还有很长的一个过程。<br>我把这个过程称之为“描述”，意思是用语言描述出来让他人能理解你的意图，最常用的方法是Stories。举个简单的例子，如果你是在做订鲜花的app，你的story应该是：小明在上班的路上，突然意识到今天是女朋友的生日，于是掏出手机，打开xxx应用，在上面订了艺术玫瑰花并完成了支付。如果有补充需求那就这样描述：当小明的女朋友收到鲜花的同时，xxx应用及时的推送了一条信息给小明。类似这样的描述，别人听着就相对容易知道你这个产品是干嘛的，增强了解和认同感。因为很可能此时的听众就是VC。<br>接着才是正在的wireframe，将stories用产品原型描述出来，这个意义在于指导开发。Wireframe指导UI输出Hi-Fi，Hi-Fi再指导代码实现。当然，这个过程就不是一个个体能够完成的了，而是需要一个团队去运作。<br>第二点，未来，如果拿来谈的话就略显心虚了。我思考的未来，应该会完成一个产业互联网的转型。传统服务行业的转型，服务自己优化，销售交给互联网运营公司。比如酒店，专心的去做好卫生、环境、餐饮娱乐，至于房间定价多少，有多少空房，价格什么时候该涨什么时候该降，这都应该由专业的公司去运营去销售。<br>另一个是数据，这里的数据并不是说所谓的大数据，用来看一年间什么时间段走高速的人最多，哪个路段最赌。而是一种预测，客户走进餐厅的那一刻起，就能猜出他要点什么菜；客户走进商场就知道他喜欢什么类型的款式。这些都是现阶段做不了的，因为数据积累还不够，更糟糕的一点，现在互联网充斥的垃圾数据太多，如何精捡也是个课题。<br>Okay，that’s all。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#谈谈“互联网”&lt;br&gt;借这个机会，让我们来说说互联网。有同学把它叫做作业，有人称之为论文，于我我想应该是随谈，谈谈我的认识，谈谈我的理解。&lt;br&gt;关于互联网会有很多话题可以聊，咱们就从一小一大两个方面去探索。一小，就是单个互联网尤其是移动互联网产品的创造历程；一大，就是未
      
    
    </summary>
    
      <category term="项目管理" scheme="http://snsfrontend.crysnower.cn/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="杂文" scheme="http://snsfrontend.crysnower.cn/tags/%E6%9D%82%E6%96%87/"/>
    
  </entry>
  
</feed>
